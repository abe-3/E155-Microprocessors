[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 1 Reflections\n\n\nBuilt and tested development board for E155.\n\n\n\n\n\nAug 29, 2025\n\n\nAbraham Rock\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nAbraham Rock\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "project/project.html",
    "href": "project/project.html",
    "title": "E155 Final Project",
    "section": "",
    "text": "DDRUM proposal."
  },
  {
    "objectID": "project/project.html#ddrum",
    "href": "project/project.html#ddrum",
    "title": "E155 Final Project",
    "section": "",
    "text": "DDRUM proposal."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Abraham Rock is a Engineering student at Harvey Mudd College in the Class of 2027. His interests lie in digital electronics, embedded systems, and systems engineering. He is in the ASHMC Executive Board where he acts as this year’s Muddlife Director. In his free times, you can find him in the Makerspace, modeling something to 3D print or finding the right classNames for MAKE."
  },
  {
    "objectID": "posts/week1-reflections.html",
    "href": "posts/week1-reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#summary",
    "href": "posts/week1-reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#reflections-on-lab",
    "href": "posts/week1-reflections.html#reflections-on-lab",
    "title": "Week 1 Reflections",
    "section": "Reflections on Lab",
    "text": "Reflections on Lab\nI’m excited to improve my Verilog skills and getting more familiar with the idomatic style of the language and how these skills are already helping me with clinic. Struggled with learning all the software and fixing connection issues and other miscellanous warnings / errors I had run into but should help me with this class throughout the semester."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Hours spent on lab: 45 Hours\n\nHours procrastinated: Hours :(\n\n\n\nOverview\nIn this lab, expanding on our clock multiplexing knowledge from Lab 2, we controlled a two digit 7-segment-display via inputs of a keypad. This 4 x 4 keypad we use has 8 pins for each row and column connection. We display the most recent input on the right digit of the 7-segment-display. On subsequent inputs of the keypad, we should shift the value displayed from the right digit to the left digit of the 7-segment-display and simultaneously update the right digit with the new input of the keypad.\n\n\nHardware Setup\nWe have a very similar circuit as lab 2 where we used a PNP transistor to control which segment was powered to display two digits with limited pins avaliable. This is my breadboard:\n\n\n\nLab 3 Circuit Breadboard\n\n\n\n\nCalculations\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, Push Buttons, and the 7-segment display.\n\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Hours spent on lab: 5 Hours\n\n\nOverview\nIn this lab, we learn about interrupts, a mechanism to do some action when you detect something. This method compared to polling saves on MCU’s CPU usage, letting the MCU rest or do other tasks and only do the desired action only when needed. We used motor 25GA370 to read out the encoded and waves.\n\n\nHardware Setup\nI followed the wiring diagram on the Motor 25GA370 Datasheet. Then checked Table 13 and 14 on the STM32L432KCUx MCU Datasheet to choose PB1 and PB7 as 5 Volt tolerant pins:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU and the Motor.\n\n\n\nSchematic\n\n\nAdditionally, my flowchart drawing showing the interrupts is here including two separate EXTI registers on the MCU.\n\n\n\nFlowchart\n\n\n\n\nCalculations\n\nAngular Velocity Calculation (Interrupts)\nLooking through the datasheets, we see our motor has some constant 408 \\(\\frac{\\text{Ticks}}{\\text{Revolution}}\\). Doing some rearranging we discover that we’re going to need to compute the amount of ticks occuring in some time interval to find \\(\\frac{\\text{Ticks}}{\\text{Time}}\\). Taking the quotient of these values … \\(\\frac{\\frac{\\text{Ticks}}{\\text{Time}}}{\\frac{\\text{Ticks}}{\\text{Revolution}}} = \\frac{\\text{Revolutions}}{\\text{Time}}\\) which is angular velocity. So using a 200 ms sample period and triggering on the rising and falling edge of both signals, let’s increment or decrement some counter (for direction) and then divide by the 4 \\(\\times\\) the sample period to get our desired unknown: \\(\\frac{\\text{Ticks}}{\\text{Time}}\\).\n\n\nPolling Comparison\nFirst calibrating my MCU by toggling a pin on and off in a while loop, we can see the fastest frequency our main function can operate is roughly \\(15 kHz\\). Taking the inverse, we see our sample period is \\(T_{MCU} = 66.6 \\micro s\\).\n\n\n\nPolling Rates\n\n\nAdditionally, looking at the encoder outputs of our motor, the occur at roughly \\(1 kHz\\). Which is updating every 1 ms.\nUsing the Nyquist-Shannon Sampling Theorem (thank you Prof. Bassman & Prof. Yong): \\(F_{\\text{Sampling}} = 2 \\times F_{\\text{Max}}\\). Since our main loop samples at 15 kHz, and the encoder outputs pulses at \\(~1 kHz\\), we are oversampling by nearly two orders of magnitude. According to the Nyquist–Shannon Sampling Theorem, we would need at least a \\(2 kHz\\) sampling rate to accurately capture this signal, and our polling method catches more than enough encoder transitions.\nGiven the encoder produces 408 ticks per revolution and operates near 1 kHz, the motor speed corresponds to approximately \\(\\frac{1000 \\text{ticks per second}}{408 \\text{ticks per revolution}}\\) = \\(2.45 \\frac{\\text{Revolutions}}{\\text{Second}}\\). Because my MCU loop runs at 15 kHz, it reads the encoder every \\(66.6 \\micro s\\) during which less than a tick should occur (0.067 ticks). This confirms that the polling rate is high enough to capture each encoder transition and accurately determine velocity.\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI.\n\n\n/* Quadrature Encoder Interface for STM32L432KC\n * Uses TIM2 in Encoder Mode with overflow/underflow interrupts\n * \n * Connections:\n * - Encoder Channel A -&gt; PA0 (TIM2_CH1)\n * - Encoder Channel B -&gt; PA1 (TIM2_CH2)\n */\n\n#include \"stm32l4xx_hal.h\"\n\n// Global variables\nTIM_HandleTypeDef htim2;\nvolatile int32_t encoder_count = 0;\nvolatile uint32_t overflow_count = 0;\n\n// Initialize quadrature encoder on TIM2\nvoid Encoder_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    TIM_Encoder_InitTypeDef sConfig = {0};\n    TIM_MasterConfigTypeDef sMasterConfig = {0};\n\n    __HAL_RCC_TIM2_CLK_ENABLE();\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 0;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 0xFFFFFFFF;\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n\n    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;\n    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC1Filter = 0x0F;\n    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC2Filter = 0x0F;\n\n    if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)\n        Error_Handler();\n\n    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n        Error_Handler();\n\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);\n\n    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);\n    HAL_NVIC_EnableIRQ(TIM2_IRQn);\n    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)\n    {\n        if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)\n        {\n            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);\n            if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))\n                overflow_count--;\n            else\n                overflow_count++;\n        }\n    }\n}\n\nint32_t Encoder_GetCount(void)\n{\n    uint32_t tim_count = __HAL_TIM_GET_COUNTER(&htim2);\n    int32_t adjusted_count = (int32_t)(tim_count - 0x7FFFFFFF);\n    return adjusted_count + (overflow_count * 0x100000000LL);\n}\n\nvoid Encoder_Reset(void)\n{\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    overflow_count = 0;\n    encoder_count = 0;\n}\n\nint32_t Encoder_GetVelocity(void)\n{\n    static int32_t last_count = 0;\n    int32_t current_count = Encoder_GetCount();\n    int32_t velocity = current_count - last_count;\n    last_count = current_count;\n    return velocity;\n}\n\nint8_t Encoder_GetDirection(void)\n{\n    return __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2) ? -1 : 1;\n}\n\n__weak void Error_Handler(void)\n{\n    __disable_irq();\n    while (1) {}\n}\n\n\nI think the AI did okay this week. It wanted to use STM32L4xx-hal-driver library and I didn’t put in a lot of effort getting that import to work. Also my check-off is in an hour and I would like to do work in other more important places. Briefly searching through the library, It looks like everything exists and it would likely compile however, I am skeptical of the velocity calculations.\n\n\nConclusion\nThe design worked as intended. The interrupts trigger on the rising and falling edge of each signal and computes the correct angular velocity and direction of spin."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Hours spent on lab: 12 Hours\n\n\nOverview\nAfter learning SPI Communication in Lab 6, we are returning back to System Verilog and our FPGA to incorporate our new learned skill to have them communicate. Our Microcontroller will act as the host, sending a 128-bit plaintext message and a 128-bit key via SPI. Our FPGA performs a very complex sequence of operations to function as a 128-bit AES encryption hardware accelerator. The FPGA receives the inputs, computes the encryption, and transmits the resulting ciphertext back to the microcontroller for verification.\n\n\nBlock Diagram\nThe block diagram for the hardware involves a top-level module (aes_starter) which instantiates the provided SPI interface and the custom aes_core module.\nDue to synthesis constraints, the logic is too large to implement all encryption rounds as one giant block of combinational logic. Therefore, the aes_core must be designed to perform the rounds sequentially. This architecture is partitioned into a datapath and a controller.\nController: A Finite State Machine (FSM) that generates the control signals to manage the flow of data through the datapath. It sequences the 10 rounds of encryption, asserts the correct multiplexer select signals, and manages register enables. The FSM must account for the one-cycle latency of the sbox synchronous RAM lookup.\nDatapath: Consists of registers to hold the 128-bit intermediate state and the round key. It includes multiplexers and the combinational logic blocks for the four main AES transformations:\n\nsbox: The provided byte-substitution module (using sbox.txt).\nShiftRows: A combinational wire-shuffling module.\nMixColumns: The provided Galois field arithmetic module.\nAddRoundKey: A bitwise XOR operation.\n\nThe controller dictates when the state register is loaded and which transformation’s output is fed back as the next input, iterating until the final ciphertext is produced and ready for SPI transmission.\n\n\n\nBlock Diagram\n\n\n\n\nSimulation Verification\nFor my 4 custom modules to implement AES Encryption, you can see my verification of each of them:\n\n\n\n\n  \n\nTop Level SPI Testbench\n\n\n\n  \n\nMain Core Module Testbench\n\n\n\n\n\n\n  \n\nKey Expansion Testbench\n\n\n\n  \n\nRound Logic Testbench\n\n\n\n  \n\nSubbytes Testbench\n\n\n\n\n\nHardware Verification\nConnecting the SPI data pins to the oscilloscope logic analyzer and running a SPI function like our temperature read function, we can visualize the command signals, SPI output, and encrypted words being sent to and from the FPGA.\n\n\nPlain Text - Logic Analyzer Trace\n\n\n        \n\n\nKey - Logic Analyzer Trace\n\n\n       \n\n\nCipher Text - Logic Analyzer Trace\n\n\n       \n\n\n\nAI Prototype\nThis week I prompted ChatGPT with “Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.” For additional context, I provided the NIST AES Specifications.\n\n\n// aes_keyexp_round.sv\n// Combinational per-round AES-128 KeyExpansion\n// Assumes SUBWORD and ROTWORD are provided elsewhere.\n// Produces next 128-bit round key from previous 128-bit round key and round number.\n//\n// Reference: FIPS-197 Algorithm 2 (KEYEXPANSION) and Table 5 (Rcon). \n\nmodule aes_keyexp_round #(\n    parameter int AES_NK = 4   // only AES_NK==4 (AES-128) is implemented here\n) (\n    input  logic [127:0] prev_key,   // previous round key: {w0, w1, w2, w3} (big-endian word order)\n    input  logic [3:0]   round_idx,  // round index (1..10 for AES-128). round_idx==0 -&gt; next_key = prev_key (default)\n    output logic [127:0] next_key\n);\n\n    // Rcon table (words): index 1..10 valid for AES-128\n    localparam logic [31:0] RCON [1:10] = '{\n        32'h01000000, 32'h02000000, 32'h04000000, 32'h08000000,\n        32'h10000000, 32'h20000000, 32'h40000000, 32'h80000000,\n        32'h1b000000, 32'h36000000\n    };\n\n    // Word extraction (big-endian grouping)\n    logic [31:0] w0, w1, w2, w3;\n    assign {w0, w1, w2, w3} = prev_key; // prev_key[127:96] = w0, [95:64]=w1, [63:32]=w2, [31:0]=w3\n\n    // External helpers (assumed implemented elsewhere).\n    // Provide prototypes so synthesis/simulation tools know the calls exist.\n    // Replace these with module/task calls if your implementation exposes them differently.\n    function automatic logic [31:0] SUBWORD(input logic [31:0] in_word);\n        // implemented elsewhere; prototype only\n    endfunction\n\n    function automatic logic [31:0] ROTWORD(input logic [31:0] in_word);\n        // implemented elsewhere; prototype only\n    endfunction\n\n    // Internal temps / outputs\n    logic [31:0] temp, nw0, nw1, nw2, nw3;\n\n    // Combinational expansion logic (AES-128/Nk==4)\n    always_comb begin\n        // Default: pass-through if round_idx == 0\n        if (AES_NK != 4) begin\n            // Not implemented for Nk != 4 in this module.\n            // Output zeros to make behavior deterministic; caller should not use this for Nk != 4.\n            next_key = '0;\n        end else if (round_idx == 0) begin\n            next_key = prev_key;\n        end else begin\n            // temp = SUBWORD(ROTWORD(w3)) XOR Rcon[round_idx]\n            // round_idx range check: clamp 1..10 for AES-128\n            int rindex = (round_idx &lt; 1) ? 1 : (round_idx &gt; 10) ? 10 : round_idx;\n            temp = SUBWORD(ROTWORD(w3)) ^ RCON[rindex];\n\n            // w4 = w0 ^ temp\n            nw0 = w0 ^ temp;\n            // w5 = w1 ^ w4\n            nw1 = w1 ^ nw0;\n            // w6 = w2 ^ w5\n            nw2 = w2 ^ nw1;\n            // w7 = w3 ^ w6\n            nw3 = w3 ^ nw2;\n\n            next_key = {nw0, nw1, nw2, nw3};\n        end\n    end\nendmodule\n\n\nThe AI did pretty bad this week. The logic and sequence makes sense, however, it already is far too big to upload to our Upduino FPGA, likely because of the 96 XOR operations happening in parallel and the large functions it is declaring.\nWe can continue and see how the same LLM will perform for the same task with a new prompt: “Write SystemVerilog HDL to implement the following logic:\n\n\ni = 0\nwhile i &lt; Nk do\n    w[i] &lt;- key[4*i..4*i+3]\n    i &lt;- i+1\nend while\nwhile i &lt;= 4 * Nr + 3 do\n    temp &lt;- w[i-1]\n    if i mod Nk = 0 then\n        temp &lt;- module1(module2(temp)) (+) Rcon[i/Nk]\n    else if Nk &gt; 6 and i mod Nk = 4 then\n        temp &lt;- module1(temp)\n    end if\n    w[i] &lt;- w[i-Nk] (+) temp\n    i &lt;- i + 1\nend while\nreturn w\n\n\nAssume module1 and module2 are existing modules that can be instantiated. (+) refers to XOR. Unwrap the loop in the provided pseudo code so it uses the previous iterations output to generate the new iteration.\nDo not use any existing knowledge of the AES specifications in your answer.”\nIt produces the following:\n\n\nmodule KeyExpansion #(\n    parameter int Nk = 4,              // number of key words\n    parameter int Nr = 10              // number of rounds\n)(\n    input  logic [32*Nk-1:0] key,      // input key (Nk words)\n    input  logic [31:0]       Rcon   [0:((4*Nr+3)/Nk)],\n    output logic [32*(4*Nr+4)-1:0] w   // expanded key words\n);\n\n    // Intermediate array of words\n    logic [31:0] w_array [0:(4*Nr+3)];\n    logic [31:0] temp;\n    logic [31:0] mod1_out, mod2_out;\n\n    // Modules (instantiated once, used combinationally)\n    module1 u_mod1 (.in(temp), .out(mod1_out));\n    module2 u_mod2 (.in(temp), .out(mod2_out));\n\n    // Initial Nk words come directly from key\n    genvar i;\n    generate\n        for (i = 0; i &lt; Nk; i++) begin\n            assign w_array[i] = key[32*i +: 32];\n        end\n    endgenerate\n\n    // Iteratively expand key schedule\n    always_comb begin\n        for (int j = Nk; j &lt;= 4*Nr + 3; j++) begin\n            temp = w_array[j-1];\n            if ((j % Nk) == 0) begin\n                temp = mod1_out ^ Rcon[j/Nk];\n            end\n            else if ((Nk &gt; 6) && ((j % Nk) == 4)) begin\n                temp = mod1_out;\n            end\n            w_array[j] = w_array[j-Nk] ^ temp;\n        end\n    end\n\n    // Flatten w_array to output vector\n    generate\n        for (i = 0; i &lt;= 4*Nr + 3; i++) begin\n            assign w[32*i +: 32] = w_array[i];\n        end\n    endgenerate\nendmodule\n\n\nSimilarily to last time, this module is extremely expensive. ChatGPT is mindlessly running a lot of for loops many times more than necessary creating a lot fo extra hardware.\n\n\nConclusion\nThe design worked as intended. Our top level testbench passes with no errors and successfully returns the decrypted word."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Hours spent on lab: 12 Hours\n\n\nOverview\nIn this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input. This is shown below.\n\n\n\nInput\nOutput\nLogic\n\n\n\n\nS[0:1]\nOnboard Led 0\nXOR\n\n\nS[2:3]\nOnboard Led 1\nAND\n\n\n\\(48\\) Mhz Oscillator\nOnboard Led 2\n2.4 Hz Blinking\n\n\nS[0:6]\n7 Segment Display\nBinary Decoder\n\n\n\n\n\nHardware Setup\nI followed the Lab 1 guide for assembling and soldering my development board in addition to the interactive site.\n\n\n\n\nMCU and FPGA Development Board\n\n\n\n\n\nBoard Backside View\n\n\n\n\n\nRibbon Extender Connection\n\n\n\n\n\nCalculations\nAssuming our 7 Segment Display LEDs have a drop of 2V and we want to restrict the current flow through the display to less than 20 milliamps. Using Ohm’s Law: \\(V = IR\\) we can rearrange to solve for resistance: \\(R = \\frac{V}{I}\\). Then plugging in our values: \\(\\frac{[3.3 V - 2 V] - 0 V}{20 \\times 10^{\\3} A} = 65 \\Omega\\). So I will use a resistor larger than \\(65 \\Omega\\), the nearest size up stocked in the Engineering Stockroom being \\(68 \\Omega\\), restricting the current through the display to \\(19\\) mA of current.\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\nI created a testbench for each of the modules I made. The testbenches loads testvectors that simulate all of the combinational logic of switches and LED and 7 Segment Display outputs against each other to make sure the outputs are what I expect when the module is run. You can see below my waveforms generated from my 3 simulations\n\n\n\n\nTop Level Module\n\n\n\n\n\n\nLED Module\n\n\n\n\n\n7 Segment Display Module\n\n\n\n\nThe top level module ran 16 tests with 0 errors !\n\n\nHardware Testing\n\n\n\nOscilloscope Trace of led[2] pin 42\n\n\n\n\n\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”.\nCompiling the given code resulted in 1 error and 12 warnings: Error 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/abrah/onedrive/documents/lab1_ai/source/impl_1/lab1_ai.sv(21): instantiating unknown module SB_HFOSC. VERI-1063 [lab1_ai.sv:21]\nIt simply suggested I didn’t have the module installed but it was trying to access a oscillator not compatible with our board. I fixed the oscillator declaration for it then it compiled fine.\n\n\nResults\nAll lab requirements were met. The E155 development board is fully assembled and operational, except for a broken ribbon cable connector that needs replacement. The FPGA is programmed with synthesized Verilog, successfully driving the LEDs and 7-segment display as specified. Both simulation and hardware tests confirm correct operation, with the 7-segment display showing all digits clearly and equally bright."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "section": "",
    "text": "Hours spent on lab: 15 Hours\n\n\nOverview\nIn this lab, we learn about one of the most used methods of data communication, Serial Peripheral Interface or SPI. This saves people from making cumbersome circuits and avoid wiring many different signals in parallel. For learning this, we are using the DS1722 Temperature Sensor which communicates some hex value based on the temperature which you can translate to some threshold to find temperature in known units.\n\n\nHardware Setup\nWe were provided with a breakout board to easily access the necessary Power and SPI pins. I connected the \\(\\text{COPI}\\), \\(\\text{CIPO}\\), \\(\\text{S}_{\\text{CLK}}\\), and \\(\\text{CS}\\) pins respectively from our MCU’s development board to our Temperature Sensor.\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU, and the DS1722 Temperature Sensor.\n\n\n\nSchematic\n\n\n\n\nCalculations\nThe method of reading temperature through SPI is \\(\\text{Temperature} [\\degree \\text{C}] = \\text{MSB} + \\frac{\\text{LSB}}{256}\\). Which we can retrieve by shifting the 8-bit word by 8 to get the most significant bit.\n\n\n\nResolution (bits)\nCommand Byte\nConversion Time (ms)\n\n\n\n\n8\n0xE0\n75\n\n\n9\n0xE2\n150\n\n\n10\n0xE4\n300\n\n\n11\n0xE6\n600\n\n\n12 (default)\n0xE8\n1200\n\n\n\n\n\nVerification\nConnecting the SPI data pins to the oscilloscope logic analyzer and running a SPI function like our temperature read function, we can visualize the command signals, dummy bits, and SPI output (LSB and MSB) on the oscilloscope.\n\n\n\nLogic Analyzer Trace\n\n\n\n\nAI Prototype\nThis week I prompted ChatGPT with “I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.” For additional context, I provided the macros I was using for pin outs.\n\n\n\nAI Prototype\n\n\n\n\n#include \"stm32l432xx.h\"\n#include stdint.h\n\n#define DS1722_CS_LOW()    (GPIOA-&gt;BSRR = (1U &lt;&lt; (SPI_CS + 16))) // Clear bit\n#define DS1722_CS_HIGH()   (GPIOA-&gt;BSRR = (1U &lt;&lt; SPI_CS))        // Set bit\n\n#define DS1722_READ_CMD    0x02  // Read temperature MSB register\n#define DS1722_TEMP_MSB    0x02  // Address of temperature MSB register\n\nfloat read_temp_DS1722(void)\n{\n    uint8_t msb, lsb;\n    uint16_t raw_temp;\n\n    // Select DS1722\n    DS1722_CS_LOW();\n\n    // Send address of temperature MSB (auto-increment allows reading both bytes)\n    while (!(SPI1-&gt;SR & SPI_SR_TXE));\n    *((__IO uint8_t *)&SPI1-&gt;DR) = DS1722_TEMP_MSB;\n    while (!(SPI1-&gt;SR & SPI_SR_RXNE));\n    (void)SPI1-&gt;DR; // dummy read to clear RXNE\n\n    // Read MSB\n    while (!(SPI1-&gt;SR & SPI_SR_TXE));\n    *((__IO uint8_t *)&SPI1-&gt;DR) = 0x00;  // dummy byte\n    while (!(SPI1-&gt;SR & SPI_SR_RXNE));\n    msb = SPI1-&gt;DR;\n\n    // Read LSB\n    while (!(SPI1-&gt;SR & SPI_SR_TXE));\n    *((__IO uint8_t *)&SPI1-&gt;DR) = 0x00;\n    while (!(SPI1-&gt;SR & SPI_SR_RXNE));\n    lsb = SPI1-&gt;DR;\n\n    // Deassert CS\n    DS1722_CS_HIGH();\n\n    // Combine and convert\n    raw_temp = ((uint16_t)msb &lt;&lt; 8) | lsb;\n    float temp_c = (float)raw_temp / 256.0f; // 1 LSB = 1/256 °C\n\n    return temp_c;\n}\n\n\nI think the AI did really good this week. Its design looks like some cheap web app that I’d see which is sort of nice and well within specification.\nFor the actual reading temperature SPI code, I was very impressed, SPI has a lot of configuration options that I definetly struggled the most with and assumed the LLM would hallucinate registers or settings making it not work.\nSubstiting both the web page and SPI reading function didn’t make any functionality changes to my project making it work just as intended.\n\n\nConclusion\nThe design worked as intended. The temperature can go seamlessly into the negative range and reads what seems like reasonable values. A user can select a reading resolution through the webpage."
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-3-keypad-scanner",
    "href": "labs/labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-4-digital-audio",
    "href": "labs/labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-5-interrupts",
    "href": "labs/labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "href": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\nTO-DO"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Hours spent on lab: 15 Hours\n\nHours procrastinated: 45 Hours :(\n\n\n\nOverview\nIn this lab, expanding on our 7-segment-display knowledge from Lab 1, we controlled a two digit 7-segment-display with the same pins via multiplexing the power pins based on the clock signal. Controlling each segment with independent combinational logic, we toggle between them fast enough to appear as if they are both independently running. Finally, we display the sum of the two numbers displayed on the digits as a binary sum in the form of LEDs.\n\n\nHardware Setup\nOur FPGA has 18 GPIO pins available for use. The two 7-segment-displays require 7 pins for each segment, and 2 pins for powering them (while an inverter chip could’ve been used, it would’ve been more to breadboard and the pin was available for use). 4 Input pins for the DiP switches and 5 output pins for the summation LEDs, so we utilized all available programmable pins on our FPGA. This is my breadboard:\n\n\n\nLab 2 Circuit Breadboard\n\n\n\n\nCalculations\n\nTransistor Current through the Base:\nThe drop of the diode in the transistor is \\(V_{BE} = 700 mV\\). Due to this drop, the Base is at \\(2.6 V\\) and the collector is at \\(3.3 V - 250 mV = 3.05 V\\). If our red 7-Segment-Display Diodes have a drop of \\(1.8V\\) … and a safe current into our FPGA is around \\(5 mA\\) so we can also see our diode light up. \\(\\frac{3.05 - 0}{5 * 10^{-3}} = 610 \\Omega\\). So for our power driving resistors … we can safely use a \\(610 \\Omega\\) Resistor or larger.\n\n\nDriving single LEDs\nSince our single red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.3 V - 1.8 V}{10*10^{-3} A} = 100 \\Omega\\).\n\n\nDriving 7-Segment-Display\nSince our 7-Segment-Display red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.1 V - 1.8 V}{5*10^{-3} A} = 260 \\Omega\\). (From \\(3.1 V\\) due to Transistor Collector).\n\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”.\nThe AI-generated code was similar to my approach, splitting the design into a top-level module, a seven-segment decoder, and a multiplexing controller. It also instantiated a high-speed oscillator for timing, which I had to fix in my own implementation due to synthesis errors. The AI’s code provided a good reference for structuring the multiplexing clock logic and handling two sets of input bits. I can appreciate how it does everything in hex too to make things a bit more readable.\nFor the next prompt: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” It again did a good job that compiled and the logic looked like it would perform well upon upload.\n\n\nResults\nAll lab requirements were met. Human eye cannot tell the flickering of my multiplexing at 60Hz. All combinations work with little to no bleed of lights or colors."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Hours spent on lab: 9 Hours\n\nHours procrastinated: \\(e^\\inf\\) Hours\n\n\n\nOverview\nIn this lab, we shift away from Hardware Description Language and our FPGA. We begin to make some set-up files for our Microcontroller STM32L432KCUx to access its internal clock, GPIO clocks, and Timer clocks to generate electrical pulses and delays in the form of square waves.\n\n\n\n\n\n\n\n\n\n\n\n\nHardware Setup\nI followed figure 9-5 on the LM386 datasheet using the audio amplifier. To create my breadboard:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU, Piano switches, Push-Buttons, and the LM386 Audio Amplifier.\n\n\n\nSchematic\n\n\n\n\nCalculations\n\nDelay\nGiven the following formulas:\n\n\\(f_{timer}=\\frac{f_{clk}}{PSC+1}\\)\n\\(f_{reload}=\\frac{f_{timer}}{ARR+1}\\)\n\\(T=\\frac{PSC+1}{f_{clk}}\\times (ARR+1)\\)\n\nHardcoding PSC for delay as 2500, we can use our first equation \\(f_{timer}=\\frac{80 * 10^6 Hz}{2501} \\approx 31987.2 Hz\\). We can then use our 3rd equation to see our minimum and maximum delay depending on what \\(ARR\\) is set as as the incrementer.\nMinimum (ARR = 1): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (2) \\approx 62.5 \\mu s\\).\nMaximum (ARR = 65635 = 0xFFFF): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (65535) \\approx 2.05 s\\).\n\n\n\nPulse Width Modulation\nGiven the following formula:\n\n\\(f_{pwm}=\\frac{f_{clk}}{(PSC+1)(ARR+1)}\\)\n\nMinimum (largest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{65535^2} \\approx 18.627 mHz\\)\nMaximum (smallest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{2} = 40 MHz\\)\nSo let’s go through some examples to see how accurate our production is even with the rounding and integer division taking place.\n78 Hz (Eb2):\n\\(D = \\frac{80*10^6}{78} \\approx 1025641.03\\).\nSo my code would choose a PSC Value of \\(\\frac{1025641.03}{65536} - 1 \\approx 15.65 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(16 - 1 = 15\\).\nIt would then calculate a ARR Value of \\(\\frac{1025641.03}{15 + 1} \\approx 64102.56\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(64103\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{16 * 64103} \\approx 77.995\\).\nWe have an error of \\(\\frac{77.995 - 78}{78} \\approx -0.0064 \\%\\).\n440 Hz (A4):\n\\(D = \\frac{80*10^6}{440} \\approx 181818.\\overline{18}\\).\nSo my code would choose a PSC Value of \\(\\frac{181818.\\overline{18}}{65536} - 1 \\approx 2.8 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(3 - 1 = 2\\).\nIt would then calculate a ARR Value of \\(\\frac{181818.\\overline{18}}{2 + 1} \\approx 60606.06\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(60606\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{181818} = 440.00044\\).\nWe have an error of \\(\\frac{440.00044 - 440}{440} = 0.0001 \\%\\).\n1568 Hz (G6):\n\\(D = \\frac{80*10^6}{1568} \\approx 51020.41\\).\nSo my code would choose a PSC Value of \\(\\frac{51020.41}{65536} - 1 \\approx 0.77 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(1 - 1 = 0\\).\nIt would then calculate a ARR Value of \\(\\frac{51020.41}{0 + 1} \\approx 51020.41\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(51020\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{51021} \\approx 1567.97\\).\nWe have an error of \\(\\frac{1567.97 - 1568}{1568} \\approx -0.0019 \\%\\).\n\n\n\nVerification\n\n\n\n\n\n500 Hz Trace\n\n\nPercent Error = \\(\\frac{497.22 - 500}{500} \\approx 0.56 \\%\\) \n\n\n\n\n\n\n1000 Hz Trace\n\n\nPercent Error = \\(\\frac{994.1 - 1000}{1000} \\approx 0.59 \\%\\)\n\n\n\n\n\n\n5000 Hz Trace\n\n\nPercent Error = \\(\\frac{4973.7 - 5000}{5000} \\approx 0.53 \\%\\)\n\n\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI so it could potentially go through and not hallucinate registers.\n\n\nClaude AI Response Summary\n\n\nRecommended Timer: TIM2 (32-bit general-purpose timer)\n\n\n\nBest for 220Hz-1kHz range due to 32-bit counter flexibility\n\n\n4 channels available for PWM output\n\n\nEasy GPIO mapping via alternate functions\n\n\n\nKey Formula:\n\nf_output = f_timer / ((PSC + 1) × (ARR + 1))\n\nWhere f_timer is typically 80 MHz, PSC is the prescaler value, and ARR is the auto-reload value.\n\n\nEssential Registers:\n\n\n\nTIMx_PSC - Prescaler (divides clock)\n\n\nTIMx_ARR - Auto-reload register (defines period)\n\n\nTIMx_CCRx - Capture/compare (sets duty cycle)\n\n\nTIMx_CCMR - Set to PWM mode (OCxM = 110 or 111)\n\n\nTIMx_CCER - Enable channel output\n\n\nTIMx_CR1 - Enable counter\n\n\n\nExample (440Hz): With 80 MHz clock, PSC=79, ARR=2272 gives 440.05 Hz\n\n\nGPIO Connection: Configure pin alternate function per datasheet tables (e.g., PA0 = TIM2_CH1 with AF1)\n\n\nI think it did a good job with this response. From my understanding of the reference manual, TIM2 is one of the more robust timers on our microcontroller and could definetley be used to produce a PWM signal.\n\n\nConclusion\nThe design worked as intended. You are able to trigger the given song: Fur Elise by the press of a button, and trigger my song of choice: Un Sospiro by clicking a switch."
  },
  {
    "objectID": "project/project-proposal.html",
    "href": "project/project-proposal.html",
    "title": "Project Proposal",
    "section": "",
    "text": "Overview\nDDRUM is a four-pad rhythm game in the spirit of DDR and Guitar Hero. Notes descend in four lanes on a display while a song plays. The player strikes one of four drum pads on the beat, and the system scores accuracy as Perfect, Good, or Miss with real-time visual feedback and a running score/combo.\nThe STM32L432 (Nucleo-L432KCU) acts as the central brain and system coordinator: it reads .wav files from an SD card, performs an offline FFT-based beat-detection analysis (using the CMSIS-DSP library) to auto-generate a beatmap, streams audio via I2S+DMA to a DAC, and drives the LED Matrix. The iCE40UP5K (UPduino v3.1) FPGA acts as a high-precision I/O accelerator: it captures drum pad hits with nanosecond accuracy, timestamps them, and stores them in a FIFO for the MCU to read. The result is a responsive, low-latency game that cleanly divides responsibilities: MCU for all logic, audio, and graphics; FPGA for time-critical hit detection. Success is defined as smooth 30+ FPS visuals on the Matrix, consistent audio-visual synchronization, accurate beat-detection on at least one song, consistent and accurate pad detection via the FPGA, and a real-time scoring system with a leaderboard. The design uses both the MCU and FPGA in roles beyond prior labs and introduces non-trivial new hardware: an I2S DAC, piezo sensor inputs, and an SD card reader.\n\n\nSpecifications\n\nFrame Rate: 30+ FPS steady output on 60 x 60 LED Matrix\nAudio Playback: .wav file playback via I2S DAC with DMA\nAudio Analysis: Successful offline beat-detection (bass/snare/cymbal) using the CMSIS-DSP FFT library.\nRandom Mode: A “survival” mode that uses the TRNG (True Random Number Generator) peripheral to auto-generate an endless stream of notes.\nInput Detection: Four piezo sensors captured by the FPGA with sub-microsecond precision.\nLatency Budget: End-to-end pad hit (FPGA) to MCU-read and scoring &lt;1 ms.\nScoring Windows: Perfect ±35 ms, Good ±75 ms, Miss &gt;±120 ms.\nVisual Features: Four color-coded lanes, falling notes, combo counter, and hit flash overlay on the TFT.\nMemory Reading: Reads music files, saves beatmaps, and reads/writes a persistent high-score leaderboard from an SD card using FatFs.\nTarget Success Criteria: Smooth visuals, accurate scoring, synchronized audio, and a full playable song with consistent performance.\n\n\n\nMicrocontroller Integration\nThe Nucleo-L432 provides the master clock (SysTick) for the entire system. It is responsible for all major logic. First, it implements a FAT file system (FatFs) to read .wav files from an SD card. In an “analysis” phase, it runs the CMSIS-DSP library’s FFT functions on the audio data to detect energy spikes in low/mid/high frequency bins, which it translates into a beatmap file (e.g., bass=pad1, snare=pad2) and saves back to the SD card. Second, during gameplay, it reads the .wav file again, streaming it via I2S and DMA to an external DAC for high-quality audio. Third, it simultaneously reads the generated beatmap and drives the game visuals (note highway, score) to an SPI TFT display. Fourth, it implements a “survival mode” using the TRNG peripheral to generate an unpredictable note stream. Finally, it runs the game logic, reading hit timestamps from the FPGA’s FIFO over SPI and comparing them to the master clock to determine score (Perfect/Good/Miss). This combination of DSP libraries, I2S+DMA, TRNG, and FatFs is well beyond prior labs.\n\n\nFPGA Integration\nThe iCE40UP5K is used as a high-speed, parallel I/O accelerator. Its sole task is to solve the problem of missed inputs. The four piezo drum pads (after passing through a simple comparator circuit) feed into the FPGA. The FPGA implements four high-precision timestamping modules in hardware. When a pad is hit, the FPGA captures the exact time of the rising edge (relative to its own clock) and stores this hit event (e.g., 4-bits for “lane” + 32-bits for “time”) into a hardware FIFO (First-In, First-Out) buffer. The MCU can then read from this FIFO over SPI at its own leisure (e.g., once per game loop). This design completely decouples the MCU’s main logic from the time-critical, nanosecond-precision task of input capture. This I/O co-processing, timestamping, and FIFO buffering is a new application of the FPGA.\nI believe the beat-detection algorithm will be the riskiest element of our design; tuning the FFT and onset detection to create a “fun” and accurate beatmap from an arbitrary song is a significant DSP challenge.\n\n\nCalculations\nFFT Analysis. Using the CMSIS-DSP library, a 1024-point real FFT on the Cortex-M4 (with FPU) is highly optimized. Analyzing a full 3-minute, 44.1kHz song will be an “offline” process (e.g., 10-15 seconds) shown on a loading screen. Scroll mapping. At 30 FPS each frame advances by 33.3 ms. If we want a note to travel 240 px in 1500 ms, the scroll rate is \\(v = \\frac{240}{1500} = \\frac{0.16 px}{ms}\\), so the per-frame step is \\(\\Delta y \\approx 5\\) px. SPI bandwidth. Preloading a beatmap (~10-20 KB) is fast. Runtime traffic is minimal: the MCU just needs to send a “read” command to the FPGA’s FIFO over SPI, which can run at 8–12 MHz. Latency budget. Pad analog to digital logic &lt; 100 µs; FPGA capture-to-FIFO &lt; 1 µs. MCU SPI read to game logic &lt; 100 µs. The end-to-end detection latency is well under 1 ms. The visual feedback is limited only by the TFT’s refresh rate (33 ms). This leaves ample room for scoring windows at \\(\\pm 35/ \\pm 75\\) ms. Power and levels. Logic runs at 3.3 V; I2S DAC and audio at 3.3 V or 5 V with a common ground.\n\n\nBill of Materials / Budget\n\n\n\n\n\n\n\n\n\n\n\nItem\nPart / ID\nQty\nSource\nEst. Price\nNotes\n\n\n\n\nFPGA board\nUPduino v3.1 (iCE40UP5K)\n1\nProvided\n$0.00\n\n\n\nMCU board\nNucleo-L432KCU (STM32L432KC)\n1\nProvided\n$0.00\n\n\n\nPiezo discs (27–35 mm)\ne.g., ABT-402-RP or generic\n4\n\n$4.00\nDrum sensors ($1.00 each)\n\n\nComparator (optional)\nLM393 or similar\n2-4\n\n$2.00\nSignal conditioning for FPGA\n\n\nAFE passives\n10k/100k resistors, 100 nF caps (1%)\nset\nStockroom\n$0.00\nDivider / RC\n\n\nMomentary buttons\n12 mm tactiles\n3\nStockroom\n$0.00\nStart / Select / Pause\n\n\nI2S DAC Module\nMAX98357A or PCM5102\n1\n\n$7.00\nAudio output (New)\n\n\nmicroSD Card Module\ne.g., Adafruit 254\n1\n\n$5.00\nMusic/Beatmap/Leaderboard (New)\n\n\nSPI TFT Display\n2.8” ILI9341 (320x240)\n1\n\n$15.00\nGame Display (New)\n\n\nPerfboard / wiring\n—\n—\nStockroom\n$0.00\nInterconnects\n\n\nEnclosure materials\n—\n—\nMakerspace\n$0.00\nPlywood + 3D printer filament\n\n\n\nSubtotal (purchased items): $33.00\n(This total is well within the $50 budget.)\n\n\n\nProject Timeline — Weeks 8–15\n\n\n\nWeek\nDate\nScheduled Topics\nDeliverables\nProject Milestone\n\n\n\n\n8\nOct 13\nFall Break — No Class; Proposal Debriefs\nProject Proposal\n—\n\n\n9\nOct 20\nAES Lecture & FPGA Workshop\nLab 6\n(A) MCU: Play audio from SD card via I2S+DMA. (S) FPGA: Implement piezo hit capture & FIFO.\n\n\n10\nOct 27\nGraphics, Displays, Motors & Speakers\nLab 7\n(A) MCU: Drive TFT display. Read hit timestamps from FPGA over SPI. (S) Integrate piezo-to-FPGA path.\n\n\n11\nNov 3\nDesign Review Presentations (T/Th)\nDesign Review Presentation & Memo\nDemo: Hitting a pad makes a sprite appear on the TFT, while music plays.\n\n\n12\nNov 10\nIntro to RTOS; Direct Memory Access\n—\nDevelop v1.0 of offline FFT beat-detection (CMSIS-DSP) on MCU.\n\n\n13\nNov 17\nProject Status Report & Demo; Connectors\nProject Status Reports & Demo\nDemo working game with auto-generated beatmap and scoring.\n\n\n14\nNov 24\nFFT Lecture; Thanksgiving — No Class (Th)\n—\nImplement Leaderboard. Implement TRNG random mode. Debugging/tuning.\n\n\n15\nDec 4\nDigital Signal Processing; Special Topics / Guest Lecture\nProject Checkoffs, Report, Demo Day\nWin or Die\n\n\n\n\n\nBlock Diagram\n(The previous block diagram is no longer valid. This new architecture is as follows:)\n\nInputs: Four Piezo Sensors connect to the FPGA.\nFPGA (I/O Accelerator): The FPGA’s Hit Detection + FIFO module communicates over SPI to the MCU.\nMCU (The Brain):\n\nReads/Writes to the SD Card Module (FatFs).\nDrives the SPI TFT Display.\nStreams audio to the I2S DAC Module.\nUses TRNG and CMSIS-DSP libraries.\n\nOutputs: The I2S DAC outputs to a speaker/headphones. The TFT displays the game.\n\n\n\nAction Items\n\nFinalize Audio Path (MCU side) – Implement SD card (FatFs) file reading and I2S+DMA streaming of .wav files to the DAC.\nDevelop Pad Detection (FPGA side) – Build piezo sensor circuit and implement FPGA hardware for hit timestamping and FIFO.\n[S] Implement Beat-Detection (MCU side) – Integrate CMSIS-DSP library and develop an FFT-based algorithm to auto-generate beatmaps.\nSPI Communication Protocol – Define and implement the simple “read from FIFO” SPI protocol.\nGame Logic (MCU side) – Develop the game loop, scoring logic, and leaderboard system.\nGraphics (MCU side) – Write drivers for the SPI TFT to render the note highway, score, and hit flashes.\nTRNG Mode – Use the TRNG peripheral to create a “survival” or “random” game mode.\nMechanical Integration – Assemble four-pad drum enclosure.\nSystem Integration Test – Synchronize audio, visuals, and pad timing; validate scoring.\nFinal Debug and Polish – Tune FFT algorithm, scoring windows, and prepare final demo.\n\n\n\nTask Division\n\nAbe: MCU code (FFT/Beat-detection, game logic, scoring, TRNG mode), Mechanical design (drum pad housing)\nSantiago: MCU code (I2S+DMA audio, SD Card/FatFs, SPI protocol, TFT display driver), FPGA logic (Hit capture, timestamp, FIFO)\nAll Members: Debugging, documentation, and final presentation"
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  }
]