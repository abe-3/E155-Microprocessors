[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 1 Reflections\n\n\nBuilt and tested development board for E155.\n\n\n\n\n\nAug 29, 2025\n\n\nAbraham Rock\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nAbraham Rock\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "project/project.html",
    "href": "project/project.html",
    "title": "E155 Final Project",
    "section": "",
    "text": "DDRUM proposal."
  },
  {
    "objectID": "project/project.html#ddrum",
    "href": "project/project.html#ddrum",
    "title": "E155 Final Project",
    "section": "",
    "text": "DDRUM proposal."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Abraham Rock is a Engineering student at Harvey Mudd College in the Class of 2027. His interests lie in digital electronics, embedded systems, and systems engineering. He is in the ASHMC Executive Board where he acts as this year’s Muddlife Director. In his free times, you can find him in the Makerspace, modeling something to 3D print or finding the right classNames for MAKE."
  },
  {
    "objectID": "posts/week1-reflections.html",
    "href": "posts/week1-reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#summary",
    "href": "posts/week1-reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#reflections-on-lab",
    "href": "posts/week1-reflections.html#reflections-on-lab",
    "title": "Week 1 Reflections",
    "section": "Reflections on Lab",
    "text": "Reflections on Lab\nI’m excited to improve my Verilog skills and getting more familiar with the idomatic style of the language and how these skills are already helping me with clinic. Struggled with learning all the software and fixing connection issues and other miscellanous warnings / errors I had run into but should help me with this class throughout the semester."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Hours spent on lab: 45 Hours\n\nHours procrastinated: Hours :(\n\n\n\nOverview\nIn this lab, expanding on our clock multiplexing knowledge from Lab 2, we controlled a two digit 7-segment-display via inputs of a keypad. This 4 x 4 keypad we use has 8 pins for each row and column connection. We display the most recent input on the right digit of the 7-segment-display. On subsequent inputs of the keypad, we should shift the value displayed from the right digit to the left digit of the 7-segment-display and simultaneously update the right digit with the new input of the keypad.\n\n\nHardware Setup\nWe have a very similar circuit as lab 2 where we used a PNP transistor to control which segment was powered to display two digits with limited pins avaliable. This is my breadboard:\n\n\n\nLab 3 Circuit Breadboard\n\n\n\n\nCalculations\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, Push Buttons, and the 7-segment display.\n\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Hours spent on lab: 5 Hours\n\n\nOverview\nIn this lab, we learn about interrupts, a mechanism to do some action when you detect something. This method compared to polling saves on MCU’s CPU usage, letting the MCU rest or do other tasks and only do the desired action only when needed. We used motor 25GA370 to read out the encoded and waves.\n\n\nHardware Setup\nI followed the wiring diagram on the Motor 25GA370 Datasheet. Then checked Table 13 and 14 on the STM32L432KCUx MCU Datasheet to choose PB1 and PB7 as 5 Volt tolerant pins:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU and the Motor.\n\n\n\nSchematic\n\n\nAdditionally, my flowchart drawing showing the interrupts is here including two separate EXTI registers on the MCU.\n\n\n\nFlowchart\n\n\n\n\nCalculations\n\nAngular Velocity Calculation (Interrupts)\nLooking through the datasheets, we see our motor has some constant 408 \\(\\frac{\\text{Ticks}}{\\text{Revolution}}\\). Doing some rearranging we discover that we’re going to need to compute the amount of ticks occuring in some time interval to find \\(\\frac{\\text{Ticks}}{\\text{Time}}\\). Taking the quotient of these values … \\(\\frac{\\frac{\\text{Ticks}}{\\text{Time}}}{\\frac{\\text{Ticks}}{\\text{Revolution}}} = \\frac{\\text{Revolutions}}{\\text{Time}}\\) which is angular velocity. So using a 200 ms sample period and triggering on the rising and falling edge of both signals, let’s increment or decrement some counter (for direction) and then divide by the 4 \\(\\times\\) the sample period to get our desired unknown: \\(\\frac{\\text{Ticks}}{\\text{Time}}\\).\n\n\nPolling Comparison\nFirst calibrating my MCU by toggling a pin on and off in a while loop, we can see the fastest frequency our main function can operate is roughly \\(15 kHz\\). Taking the inverse, we see our sample period is \\(T_{MCU} = 66.6 \\micro s\\).\n\n\n\nPolling Rates\n\n\nAdditionally, looking at the encoder outputs of our motor, the occur at roughly \\(1 kHz\\). Which is updating every 1 ms.\nUsing the Nyquist-Shannon Sampling Theorem (thank you Prof. Bassman & Prof. Yong): \\(F_{\\text{Sampling}} = 2 \\times F_{\\text{Max}}\\). Since our main loop samples at 15 kHz, and the encoder outputs pulses at \\(~1 kHz\\), we are oversampling by nearly two orders of magnitude. According to the Nyquist–Shannon Sampling Theorem, we would need at least a \\(2 kHz\\) sampling rate to accurately capture this signal, and our polling method catches more than enough encoder transitions.\nGiven the encoder produces 408 ticks per revolution and operates near 1 kHz, the motor speed corresponds to approximately \\(\\frac{1000 \\text{ticks per second}}{408 \\text{ticks per revolution}}\\) = \\(2.45 \\frac{\\text{Revolutions}}{\\text{Second}}\\). Because my MCU loop runs at 15 kHz, it reads the encoder every \\(66.6 \\micro s\\) during which less than a tick should occur (0.067 ticks). This confirms that the polling rate is high enough to capture each encoder transition and accurately determine velocity.\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI.\n\n\n/* Quadrature Encoder Interface for STM32L432KC\n * Uses TIM2 in Encoder Mode with overflow/underflow interrupts\n * \n * Connections:\n * - Encoder Channel A -&gt; PA0 (TIM2_CH1)\n * - Encoder Channel B -&gt; PA1 (TIM2_CH2)\n */\n\n#include \"stm32l4xx_hal.h\"\n\n// Global variables\nTIM_HandleTypeDef htim2;\nvolatile int32_t encoder_count = 0;\nvolatile uint32_t overflow_count = 0;\n\n// Initialize quadrature encoder on TIM2\nvoid Encoder_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    TIM_Encoder_InitTypeDef sConfig = {0};\n    TIM_MasterConfigTypeDef sMasterConfig = {0};\n\n    __HAL_RCC_TIM2_CLK_ENABLE();\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 0;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 0xFFFFFFFF;\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n\n    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;\n    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC1Filter = 0x0F;\n    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC2Filter = 0x0F;\n\n    if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)\n        Error_Handler();\n\n    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n        Error_Handler();\n\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);\n\n    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);\n    HAL_NVIC_EnableIRQ(TIM2_IRQn);\n    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)\n    {\n        if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)\n        {\n            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);\n            if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))\n                overflow_count--;\n            else\n                overflow_count++;\n        }\n    }\n}\n\nint32_t Encoder_GetCount(void)\n{\n    uint32_t tim_count = __HAL_TIM_GET_COUNTER(&htim2);\n    int32_t adjusted_count = (int32_t)(tim_count - 0x7FFFFFFF);\n    return adjusted_count + (overflow_count * 0x100000000LL);\n}\n\nvoid Encoder_Reset(void)\n{\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    overflow_count = 0;\n    encoder_count = 0;\n}\n\nint32_t Encoder_GetVelocity(void)\n{\n    static int32_t last_count = 0;\n    int32_t current_count = Encoder_GetCount();\n    int32_t velocity = current_count - last_count;\n    last_count = current_count;\n    return velocity;\n}\n\nint8_t Encoder_GetDirection(void)\n{\n    return __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2) ? -1 : 1;\n}\n\n__weak void Error_Handler(void)\n{\n    __disable_irq();\n    while (1) {}\n}\n\n\nI think the AI did okay this week. It wanted to use STM32L4xx-hal-driver library and I didn’t put in a lot of effort getting that import to work. Also my check-off is in an hour and I would like to do work in other more important places. Briefly searching through the library, It looks like everything exists and it would likely compile however, I am skeptical of the velocity calculations.\n\n\nConclusion\nThe design worked as intended. The interrupts trigger on the rising and falling edge of each signal and computes the correct angular velocity and direction of spin."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Overview\nTO-DO"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Hours spent on lab: 12 Hours\n\n\nOverview\nIn this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input. This is shown below.\n\n\n\nInput\nOutput\nLogic\n\n\n\n\nS[0:1]\nOnboard Led 0\nXOR\n\n\nS[2:3]\nOnboard Led 1\nAND\n\n\n\\(48\\) Mhz Oscillator\nOnboard Led 2\n2.4 Hz Blinking\n\n\nS[0:6]\n7 Segment Display\nBinary Decoder\n\n\n\n\n\nHardware Setup\nI followed the Lab 1 guide for assembling and soldering my development board in addition to the interactive site.\n\n\n\n\nMCU and FPGA Development Board\n\n\n\n\n\nBoard Backside View\n\n\n\n\n\nRibbon Extender Connection\n\n\n\n\n\nCalculations\nAssuming our 7 Segment Display LEDs have a drop of 2V and we want to restrict the current flow through the display to less than 20 milliamps. Using Ohm’s Law: \\(V = IR\\) we can rearrange to solve for resistance: \\(R = \\frac{V}{I}\\). Then plugging in our values: \\(\\frac{[3.3 V - 2 V] - 0 V}{20 \\times 10^{\\3} A} = 65 \\Omega\\). So I will use a resistor larger than \\(65 \\Omega\\), the nearest size up stocked in the Engineering Stockroom being \\(68 \\Omega\\), restricting the current through the display to \\(19\\) mA of current.\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\nI created a testbench for each of the modules I made. The testbenches loads testvectors that simulate all of the combinational logic of switches and LED and 7 Segment Display outputs against each other to make sure the outputs are what I expect when the module is run. You can see below my waveforms generated from my 3 simulations\n\n\n\n\nTop Level Module\n\n\n\n\n\n\nLED Module\n\n\n\n\n\n7 Segment Display Module\n\n\n\n\nThe top level module ran 16 tests with 0 errors !\n\n\nHardware Testing\n\n\n\nOscilloscope Trace of led[2] pin 42\n\n\n\n\n\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”.\nCompiling the given code resulted in 1 error and 12 warnings: Error 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/abrah/onedrive/documents/lab1_ai/source/impl_1/lab1_ai.sv(21): instantiating unknown module SB_HFOSC. VERI-1063 [lab1_ai.sv:21]\nIt simply suggested I didn’t have the module installed but it was trying to access a oscillator not compatible with our board. I fixed the oscillator declaration for it then it compiled fine.\n\n\nResults\nAll lab requirements were met. The E155 development board is fully assembled and operational, except for a broken ribbon cable connector that needs replacement. The FPGA is programmed with synthesized Verilog, successfully driving the LEDs and 7-segment display as specified. Both simulation and hardware tests confirm correct operation, with the 7-segment display showing all digits clearly and equally bright."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "section": "",
    "text": "Overview\nTO-DO"
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-3-keypad-scanner",
    "href": "labs/labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-4-digital-audio",
    "href": "labs/labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-5-interrupts",
    "href": "labs/labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "href": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\nTO-DO"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Hours spent on lab: 15 Hours\n\nHours procrastinated: 45 Hours :(\n\n\n\nOverview\nIn this lab, expanding on our 7-segment-display knowledge from Lab 1, we controlled a two digit 7-segment-display with the same pins via multiplexing the power pins based on the clock signal. Controlling each segment with independent combinational logic, we toggle between them fast enough to appear as if they are both independently running. Finally, we display the sum of the two numbers displayed on the digits as a binary sum in the form of LEDs.\n\n\nHardware Setup\nOur FPGA has 18 GPIO pins available for use. The two 7-segment-displays require 7 pins for each segment, and 2 pins for powering them (while an inverter chip could’ve been used, it would’ve been more to breadboard and the pin was available for use). 4 Input pins for the DiP switches and 5 output pins for the summation LEDs, so we utilized all available programmable pins on our FPGA. This is my breadboard:\n\n\n\nLab 2 Circuit Breadboard\n\n\n\n\nCalculations\n\nTransistor Current through the Base:\nThe drop of the diode in the transistor is \\(V_{BE} = 700 mV\\). Due to this drop, the Base is at \\(2.6 V\\) and the collector is at \\(3.3 V - 250 mV = 3.05 V\\). If our red 7-Segment-Display Diodes have a drop of \\(1.8V\\) … and a safe current into our FPGA is around \\(5 mA\\) so we can also see our diode light up. \\(\\frac{3.05 - 0}{5 * 10^{-3}} = 610 \\Omega\\). So for our power driving resistors … we can safely use a \\(610 \\Omega\\) Resistor or larger.\n\n\nDriving single LEDs\nSince our single red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.3 V - 1.8 V}{10*10^{-3} A} = 100 \\Omega\\).\n\n\nDriving 7-Segment-Display\nSince our 7-Segment-Display red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.1 V - 1.8 V}{5*10^{-3} A} = 260 \\Omega\\). (From \\(3.1 V\\) due to Transistor Collector).\n\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”.\nThe AI-generated code was similar to my approach, splitting the design into a top-level module, a seven-segment decoder, and a multiplexing controller. It also instantiated a high-speed oscillator for timing, which I had to fix in my own implementation due to synthesis errors. The AI’s code provided a good reference for structuring the multiplexing clock logic and handling two sets of input bits. I can appreciate how it does everything in hex too to make things a bit more readable.\nFor the next prompt: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” It again did a good job that compiled and the logic looked like it would perform well upon upload.\n\n\nResults\nAll lab requirements were met. Human eye cannot tell the flickering of my multiplexing at 60Hz. All combinations work with little to no bleed of lights or colors."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Hours spent on lab: 9 Hours\n\nHours procrastinated: \\(e^\\inf\\) Hours\n\n\n\nOverview\nIn this lab, we shift away from Hardware Description Language and our FPGA. We begin to make some set-up files for our Microcontroller STM32L432KCUx to access its internal clock, GPIO clocks, and Timer clocks to generate electrical pulses and delays in the form of square waves.\n\n\n\n\n\n\n\n\n\n\n\n\nHardware Setup\nI followed figure 9-5 on the LM386 datasheet using the audio amplifier. To create my breadboard:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU, Piano switches, Push-Buttons, and the LM386 Audio Amplifier.\n\n\n\nSchematic\n\n\n\n\nCalculations\n\nDelay\nGiven the following formulas:\n\n\\(f_{timer}=\\frac{f_{clk}}{PSC+1}\\)\n\\(f_{reload}=\\frac{f_{timer}}{ARR+1}\\)\n\\(T=\\frac{PSC+1}{f_{clk}}\\times (ARR+1)\\)\n\nHardcoding PSC for delay as 2500, we can use our first equation \\(f_{timer}=\\frac{80 * 10^6 Hz}{2501} \\approx 31987.2 Hz\\). We can then use our 3rd equation to see our minimum and maximum delay depending on what \\(ARR\\) is set as as the incrementer.\nMinimum (ARR = 1): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (2) \\approx 62.5 \\mu s\\).\nMaximum (ARR = 65635 = 0xFFFF): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (65535) \\approx 2.05 s\\).\n\n\n\nPulse Width Modulation\nGiven the following formula:\n\n\\(f_{pwm}=\\frac{f_{clk}}{(PSC+1)(ARR+1)}\\)\n\nMinimum (largest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{65535^2} \\approx 18.627 mHz\\)\nMaximum (smallest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{2} = 40 MHz\\)\nSo let’s go through some examples to see how accurate our production is even with the rounding and integer division taking place.\n78 Hz (Eb2):\n\\(D = \\frac{80*10^6}{78} \\approx 1025641.03\\).\nSo my code would choose a PSC Value of \\(\\frac{1025641.03}{65536} - 1 \\approx 15.65 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(16 - 1 = 15\\).\nIt would then calculate a ARR Value of \\(\\frac{1025641.03}{15 + 1} \\approx 64102.56\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(64103\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{16 * 64103} \\approx 77.995\\).\nWe have an error of \\(\\frac{77.995 - 78}{78} \\approx -0.0064 \\%\\).\n440 Hz (A4):\n\\(D = \\frac{80*10^6}{440} \\approx 181818.\\overline{18}\\).\nSo my code would choose a PSC Value of \\(\\frac{181818.\\overline{18}}{65536} - 1 \\approx 2.8 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(3 - 1 = 2\\).\nIt would then calculate a ARR Value of \\(\\frac{181818.\\overline{18}}{2 + 1} \\approx 60606.06\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(60606\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{181818} = 440.00044\\).\nWe have an error of \\(\\frac{440.00044 - 440}{440} = 0.0001 \\%\\).\n1568 Hz (G6):\n\\(D = \\frac{80*10^6}{1568} \\approx 51020.41\\).\nSo my code would choose a PSC Value of \\(\\frac{51020.41}{65536} - 1 \\approx 0.77 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(1 - 1 = 0\\).\nIt would then calculate a ARR Value of \\(\\frac{51020.41}{0 + 1} \\approx 51020.41\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(51020\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{51021} \\approx 1567.97\\).\nWe have an error of \\(\\frac{1567.97 - 1568}{1568} \\approx -0.0019 \\%\\).\n\n\n\nVerification\n\n\n\n\n\n500 Hz Trace\n\n\nPercent Error = \\(\\frac{497.22 - 500}{500} \\approx 0.56 \\%\\) \n\n\n\n\n\n\n1000 Hz Trace\n\n\nPercent Error = \\(\\frac{994.1 - 1000}{1000} \\approx 0.59 \\%\\)\n\n\n\n\n\n\n5000 Hz Trace\n\n\nPercent Error = \\(\\frac{4973.7 - 5000}{5000} \\approx 0.53 \\%\\)\n\n\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI so it could potentially go through and not hallucinate registers.\n\n\nClaude AI Response Summary\n\n\nRecommended Timer: TIM2 (32-bit general-purpose timer)\n\n\n\nBest for 220Hz-1kHz range due to 32-bit counter flexibility\n\n\n4 channels available for PWM output\n\n\nEasy GPIO mapping via alternate functions\n\n\n\nKey Formula:\n\nf_output = f_timer / ((PSC + 1) × (ARR + 1))\n\nWhere f_timer is typically 80 MHz, PSC is the prescaler value, and ARR is the auto-reload value.\n\n\nEssential Registers:\n\n\n\nTIMx_PSC - Prescaler (divides clock)\n\n\nTIMx_ARR - Auto-reload register (defines period)\n\n\nTIMx_CCRx - Capture/compare (sets duty cycle)\n\n\nTIMx_CCMR - Set to PWM mode (OCxM = 110 or 111)\n\n\nTIMx_CCER - Enable channel output\n\n\nTIMx_CR1 - Enable counter\n\n\n\nExample (440Hz): With 80 MHz clock, PSC=79, ARR=2272 gives 440.05 Hz\n\n\nGPIO Connection: Configure pin alternate function per datasheet tables (e.g., PA0 = TIM2_CH1 with AF1)\n\n\nI think it did a good job with this response. From my understanding of the reference manual, TIM2 is one of the more robust timers on our microcontroller and could definetley be used to produce a PWM signal.\n\n\nConclusion\nThe design worked as intended. You are able to trigger the given song: Fur Elise by the press of a button, and trigger my song of choice: Un Sospiro by clicking a switch."
  },
  {
    "objectID": "project/project-proposal.html",
    "href": "project/project-proposal.html",
    "title": "Project Proposal",
    "section": "",
    "text": "Overview\nDDRUM is a four-pad rhythm game in the spirit of DDR and Guitar Hero. Notes descend in four lanes on a display while a song plays. The player strikes one of four drum pads on the beat, and the system scores accuracy as Perfect, Good, or Miss with real-time visual feedback and a running score/combo.\nThe STM32L432 (Nucleo-L432KCU) acts as the timekeeper and system coordinator: it plays audio, timestamps pad hits, and streams visual data, and hit events to the iCE40UP5K (UPduino v3.1) FPGA over SPI. The FPGA renders the lanes and sprites at 640×480 @ 60 Hz and performs time-window scoring against the same timebase the MCU maintains. The result is a responsive, low-latency game that cleanly divides responsibilities: MCU for sensing, timing, and audio; FPGA for graphics and scoring logic. Success is defined as smooth 60 FPS visuals with four color lanes and readable targets consistent audio-visual synchronization across at least one complete charted song, consistent and accurate pad detection with low false triggers, and real-time judgments displayed without perceptible lag. The design uses both the MCU and FPGA in roles beyond prior labs and introduces non-trivial new hardware: a resistor-ladder VGA DAC, piezo sensor front-ends, and either a DFPlayer audio path or a PWM/DAC path.\n\n\nMicrocontroller Integration\nThe Nucleo-L432 provides a 1 kHz timer (or SysTick) to maintain song timing as the single time source for the entire system. It owns the visual data, schedules playback, and sends time stamp signals to the FPGA at video cadence so rendering stays phase-locked to audio. Four piezo disks mounted under pads feed simple analog front-ends. The MCU uses either the ADC analog watchdog or a comparator to raise an interrupt on being hit. We will then apply a short window of grace (about 20-30 ms) and a short signal hold to debounce a potentially buggy signal and get the fastest timestamp.\nFor audio there are two options. Option A (preferred) uses a DFPlayer Mini on UART 9600 to play MP3 from microSD; the MCU controls transport and maintains time from its own timer so that audio and visuals share the same master clock. Option B (fallback) generates PCM on the MCU with timer-DMA into a PWM or DAC output, lightly filtered and amplified to a small speaker. In either case the MCU also manages Start/Select/Pause buttons via EXTI GPIO and streams chart data to the FPGA prior to play. This combination of ADC watchdog/comparator interrupts, deterministic SPI scheduling tied to a master clock, and external audio control is beyond prior labs.\n\n\nFPGA Integration\nOn the iCE40UP5K the video pipeline uses standard 640×480p60 timing derived from an internal PLL running a ~25.2 MHz pixel clock. Horizontal and vertical counters generate pixel coordinates during the active region. Rather than allocate a full framebuffer, the renderer is a streaming compositor: for each pixel it decides which lane it falls into and whether a note sprite should be shown at that (x, y) based on the song time. A small BRAM region holds compact note tuples (drum number, time of hit) that are preloaded from the MCU before play. A separate palette/glyph LUT stores 1-bit masks for note hit flashes, and simple HUD glyphs. The mapping from scheduled onset to screen position is y = y0 + v · (sont time − hit time), where the scroll rate v is set by the chart header. A dedicated scoring core in the FPGA receives hit events from the MCU (lane and timestamp) and compares them to the nearest scheduled onset using fixed thresholds (for example ±35 ms Perfect, ±75 ms Good, Miss beyond ±120 ms). It updates combo and score, which the renderer overlays as HUD elements. The SPI slave on the FPGA parses four message types from the MCU: an INIT_HDR that carries BPM/scroll and palette parameters; NOTE_CHUNK blocks that populate BRAM; a periodic TIME_BEACON (about every 16.7 ms) that sets the authoritative song_time_ms; and immediate HIT_EVENT packets as pad interrupts occur. Video drives a simple binary-weighted 4-bit R/G/B DAC per color plus HSYNC/VSYNC to a VGA connector. This combination of a streaming sprite/LUT compositor, protocol parsing, and VGA timing extends well beyond what was covered in labs.\n\n\nCalculations\nVideo timing. 640×480 active pixels at \\(\\approx 60\\) Hz uses a \\(\\approx 25.2\\) MHz pixel clock. The streaming compositor removes the need for a full framebuffer; BRAM only stores glyphs and a compact note list. Scroll mapping. At 60 FPS each frame advances by 16.67 ms. If we want a note to travel 360 px in 2000 ms, the scroll rate is \\(v = \\frac{360}{2000} = \\frac{0.18 px}{ms}\\), so the per-frame step is \\(\\delta y \\approx 3\\) px. SPI bandwidth. Preloading a chart of about 1200 notes with 5 bytes per tuple is ~6 KB, transmitted before the song. Runtime traffic is minimal: a TIME_BEACON every frame (~60 Hz) with a few bytes and HIT_EVENTs as the player strikes. An 8–12 MHz SPI clock provides wide margin. Latency budget. Pad analog to interrupt is typically under 100 µs; packaging and SPI transmission are about 50–150 µs; the FPGA overlays judgment on the next frame (\\(\\le\\) 16.7 ms). End-to-end feedback is therefore comfortably under 10 ms typical, leaving ample room for Perfect/Good windows at \\(\\pm 35/ \\pm 75\\) ms. Power and levels. Logic runs at 3.3 V; audio/DFPlayer at 5 V with a common ground. Each VGA color channel is limited to ~0.7 Vpp into 75 \\(\\Omega\\) using a 4-bit resistor ladder with 1% tolerance and a 75 Ω series resistor per channel. No FFT processing is required in this design; key performance determinants are video timing, serial bandwidth, interrupt timing, and end-to-end latency.\n\n\nBill of Materials / Budget\n\n\n\n\n\n\n\n\n\n\n\nItem\nPart / ID\nQty\nSource\nEst. Price\nNotes\n\n\n\n\nFPGA board\nUPduino v3.1 (iCE40UP5K)\n1\nProvided\n$0.00\n\n\n\nMCU board\nNucleo-L432KCU (STM32L432KC)\n1\nProvided\n$0.00\n\n\n\nPiezo discs (27–35 mm)\ne.g., ABT-402-RP or generic\n4\n\n$4.00\nDrum sensors ($1.00 each)\n\n\nSchottky diodes\nBAT54 or similar\n4\n\n$7.00\nClamp to rails\n\n\nAFE passives\n10k/100k resistors, 100 nF caps (1%)\nset\nStockroom\n$0.00\nDivider / RC\n\n\nMomentary buttons\n12 mm tactiles\n3\nStockroom\n$0.00\nStart / Select / Pause\n\n\nDFPlayer Mini\nYX5200-24SS module\n1\n\n$6.00\nAudio output\n\n\nmicroSD card\n≥1 GB\n1\nStockroom\n$0.00\nFor DFPlayer\n\n\nAudio amplifier\nPAM8403 module\n1\n\n$2.00\n3 W class-D\n\n\nSpeaker\n8 Ω 0.5–3 W\n1\n\n$2.00\nAudio output\n\n\nVGA DAC resistors\n1 % sets: 1k, 2k, 4k, 8k + 75 Ω series\n12\nStockroom\n$0.00\n4-bit per color\n\n\nPerfboard / wiring\n—\n—\nStockroom\n$0.00\nInterconnects, DAC\n\n\nEnclosure materials\n—\n—\nMakerspace\n$0.00\nPlywood + 3D printer filament\n\n\n\nSubtotal (purchased items): $21.00\n\nDisplay / Output Options (choose one)\n\n\n\nItem\nPart / ID\nQty\nSource\nEst. Price\nNotes\n\n\n\n\nVGA monitor + cable\n—\n1\nStockroom\n$0.00\nAny VGA display\n\n\nLED Matrix\n0607\n1\nAdafruit\n$30.00\n\n\n\nLCD Screen\n1680\n1\nDigikey\n$27.50\n\n\n\nFan Display: Motor + LED strip\n2328\n1\nAdafruit\n$25.00\nMotor from stockroom\n\n\n\n\n\n\nProject Timeline — Weeks 8–15\n\n\n\nWeek\nDate\nScheduled Topics\nDeliverables\nProject Milestone\n\n\n\n\n8\nOct 13\nFall Break — No Class; Proposal Debriefs\nProject Proposal\n—\n\n\n9\nOct 20\nAES Lecture & FPGA Workshop\nLab 6\n3D Model the Drums and embed sensors\n\n\n10\nOct 27\nGraphics, Displays, Motors & Speakers\nLab 7\nGet Display Working and syncronize with music playing\n\n\n11\nNov 3\nDesign Review Presentations (T/Th)\nDesign Review Presentation & Memo\nHave working prototype model, have some pre-edited music samples\n\n\n12\nNov 10\nIntro to RTOS; Direct Memory Access\n—\n3D Model some housing for entire design\n\n\n13\nNov 17\nProject Status Report & Demo; Connectors\nProject Status Reports & Demo\nDemo working project to Prof. Spencer\n\n\n14\nNov 24\nFFT Lecture; Thanksgiving — No Class (Th)\n—\nFix what’s broken, debugging\n\n\n15\nDec 4\nDigital Signal Processing; Special Topics / Guest Lecture\nProject Checkoffs, Report, Demo Day\nWin or Die\n\n\n\n\n\nBlock Diagram\n\n\n\nBlock Diagram\n\n\n\n\nAction Items\n\nFinalize Audio Path (MCU side) – Implement DFPlayer UART control and verify synchronization with system timer.\n\nDevelop Pad Detection Circuit – Build and test piezo AFE and comparator/ADC interrupt response.\n\nSPI Communication Protocol – Define and implement INIT, NOTE_CHUNK, TIME_BEACON, and HIT_EVENT messages between MCU and FPGA.\n\nFPGA Video Pipeline – Implement 640×480 VGA timing, streaming compositor, and BRAM note storage.\n\nScoring Logic – Design and verify time-window scoring (Perfect/Good/Miss) on FPGA.\n\nHUD & Sprite Rendering – Create lane graphics, combo counter, and hit flash overlays.\n\nMechanical Integration – Assemble four-pad drum enclosure with sensor mounts and wiring.\n\nSystem Integration Test – Synchronize audio, visuals, and pad timing; validate latency budget.\n\nFinal Debug and Polish – Tune thresholds, test multiple charts, and prepare final demo.\n\n\n\nTask Division\n\nAbe: MCU code (drum sensing, audio integration), Scoring logic, Mechanical design (drum pad housing, sensor mounting)\nSantiago: MCU code (timing, SPI protocol), FPGA graphics pipeline, VGA output,\nAll Members: Debugging, documentation, and final presentation"
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  }
]