[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 1 Reflections\n\n\nBuilt and tested development board for E155.\n\n\n\n\n\nAug 29, 2025\n\n\nAbraham Rock\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nAbraham Rock\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/soupsieve-2.8.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Abraham Rock is a Engineering student at Harvey Mudd College in the Class of 2027. His interests lie in digital electronics, embedded systems, and systems engineering. He is in the ASHMC Executive Board where he acts as this year’s Muddlife Director. In his free times, you can find him in the Makerspace, modeling something to 3D print or finding the right classNames for MAKE."
  },
  {
    "objectID": "posts/week1-reflections.html",
    "href": "posts/week1-reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#summary",
    "href": "posts/week1-reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "Soldered development board together and practice Lattice Radiant and Segger compilation on the FPGA and MCU respectively."
  },
  {
    "objectID": "posts/week1-reflections.html#reflections-on-lab",
    "href": "posts/week1-reflections.html#reflections-on-lab",
    "title": "Week 1 Reflections",
    "section": "Reflections on Lab",
    "text": "Reflections on Lab\nI’m excited to improve my Verilog skills and getting more familiar with the idomatic style of the language and how these skills are already helping me with clinic. Struggled with learning all the software and fixing connection issues and other miscellanous warnings / errors I had run into but should help me with this class throughout the semester."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Hours spent on lab: 45 Hours\n\nHours procrastinated: Hours :(\n\n\n\nOverview\nIn this lab, expanding on our clock multiplexing knowledge from Lab 2, we controlled a two digit 7-segment-display via inputs of a keypad. This 4 x 4 keypad we use has 8 pins for each row and column connection. We display the most recent input on the right digit of the 7-segment-display. On subsequent inputs of the keypad, we should shift the value displayed from the right digit to the left digit of the 7-segment-display and simultaneously update the right digit with the new input of the keypad.\n\n\nHardware Setup\nWe have a very similar circuit as lab 2 where we used a PNP transistor to control which segment was powered to display two digits with limited pins avaliable. This is my breadboard:\n\n\n\nLab 3 Circuit Breadboard\n\n\n\n\nCalculations\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, Push Buttons, and the 7-segment display.\n\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Hours spent on lab: 5 Hours\n\n\nOverview\nIn this lab, we learn about interrupts, a mechanism to do some action when you detect something. This method compared to polling saves on MCU’s CPU usage, letting the MCU rest or do other tasks and only do the desired action only when needed. We used motor 25GA370 to read out the encoded and waves.\n\n\nHardware Setup\nI followed the wiring diagram on the Motor 25GA370 Datasheet. Then checked Table 13 and 14 on the STM32L432KCUx MCU Datasheet to choose PB1 and PB7 as 5 Volt tolerant pins:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU and the Motor.\n\n\n\nSchematic\n\n\nAdditionally, my flowchart drawing showing the interrupts is here including two separate EXTI registers on the MCU.\n\n\n\nFlowchart\n\n\n\n\nCalculations\n\nAngular Velocity Calculation (Interrupts)\nLooking through the datasheets, we see our motor has some constant 408 \\(\\frac{\\text{Ticks}}{\\text{Revolution}}\\). Doing some rearranging we discover that we’re going to need to compute the amount of ticks occuring in some time interval to find \\(\\frac{\\text{Ticks}}{\\text{Time}}\\). Taking the quotient of these values … \\(\\frac{\\frac{\\text{Ticks}}{\\text{Time}}}{\\frac{\\text{Ticks}}{\\text{Revolution}}} = \\frac{\\text{Revolutions}}{\\text{Time}}\\) which is angular velocity. So using a 200 ms sample period and triggering on the rising and falling edge of both signals, let’s increment or decrement some counter (for direction) and then divide by the 4 \\(\\times\\) the sample period to get our desired unknown: \\(\\frac{\\text{Ticks}}{\\text{Time}}\\).\n\n\nPolling Comparison\nFirst calibrating my MCU by toggling a pin on and off in a while loop, we can see the fastest frequency our main function can operate is roughly \\(15 kHz\\). Taking the inverse, we see our sample period is \\(T_{MCU} = 66.6 \\micro s\\).\n\n\n\nPolling Rates\n\n\nAdditionally, looking at the encoder outputs of our motor, the occur at roughly \\(1 kHz\\). Which is updating every 1 ms.\nUsing the Nyquist-Shannon Sampling Theorem (thank you Prof. Bassman & Prof. Yong): \\(F_{\\text{Sampling}} = 2 \\times F_{\\text{Max}}\\). Since our main loop samples at 15 kHz, and the encoder outputs pulses at \\(~1 kHz\\), we are oversampling by nearly two orders of magnitude. According to the Nyquist–Shannon Sampling Theorem, we would need at least a \\(2 kHz\\) sampling rate to accurately capture this signal, and our polling method catches more than enough encoder transitions.\nGiven the encoder produces 408 ticks per revolution and operates near 1 kHz, the motor speed corresponds to approximately \\(\\frac{1000 \\text{ticks per second}}{408 \\text{ticks per revolution}}\\) = \\(2.45 \\frac{\\text{Revolutions}}{\\text{Second}}\\). Because my MCU loop runs at 15 kHz, it reads the encoder every \\(66.6 \\micro s\\) during which less than a tick should occur (0.067 ticks). This confirms that the polling rate is high enough to capture each encoder transition and accurately determine velocity.\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI.\n\n\n/* Quadrature Encoder Interface for STM32L432KC\n * Uses TIM2 in Encoder Mode with overflow/underflow interrupts\n * \n * Connections:\n * - Encoder Channel A -&gt; PA0 (TIM2_CH1)\n * - Encoder Channel B -&gt; PA1 (TIM2_CH2)\n */\n\n#include \"stm32l4xx_hal.h\"\n\n// Global variables\nTIM_HandleTypeDef htim2;\nvolatile int32_t encoder_count = 0;\nvolatile uint32_t overflow_count = 0;\n\n// Initialize quadrature encoder on TIM2\nvoid Encoder_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    TIM_Encoder_InitTypeDef sConfig = {0};\n    TIM_MasterConfigTypeDef sMasterConfig = {0};\n\n    __HAL_RCC_TIM2_CLK_ENABLE();\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 0;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 0xFFFFFFFF;\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n\n    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;\n    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC1Filter = 0x0F;\n    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC2Filter = 0x0F;\n\n    if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)\n        Error_Handler();\n\n    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n        Error_Handler();\n\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);\n\n    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);\n    HAL_NVIC_EnableIRQ(TIM2_IRQn);\n    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)\n    {\n        if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)\n        {\n            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);\n            if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))\n                overflow_count--;\n            else\n                overflow_count++;\n        }\n    }\n}\n\nint32_t Encoder_GetCount(void)\n{\n    uint32_t tim_count = __HAL_TIM_GET_COUNTER(&htim2);\n    int32_t adjusted_count = (int32_t)(tim_count - 0x7FFFFFFF);\n    return adjusted_count + (overflow_count * 0x100000000LL);\n}\n\nvoid Encoder_Reset(void)\n{\n    __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n    overflow_count = 0;\n    encoder_count = 0;\n}\n\nint32_t Encoder_GetVelocity(void)\n{\n    static int32_t last_count = 0;\n    int32_t current_count = Encoder_GetCount();\n    int32_t velocity = current_count - last_count;\n    last_count = current_count;\n    return velocity;\n}\n\nint8_t Encoder_GetDirection(void)\n{\n    return __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2) ? -1 : 1;\n}\n\n__weak void Error_Handler(void)\n{\n    __disable_irq();\n    while (1) {}\n}\n\n\nI think the AI did okay this week. It wanted to use STM32L4xx-hal-driver library and I didn’t put in a lot of effort getting that import to work. Also my check-off is in an hour and I would like to do work in other more important places. Briefly searching through the library, It looks like everything exists and it would likely compile however, I am skeptical of the velocity calculations.\n\n\nConclusion\nThe design worked as intended. The interrupts trigger on the rising and falling edge of each signal and computes the correct angular velocity and direction of spin."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "Overview\nTO-DO"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Hours spent on lab: 12 Hours\n\n\nOverview\nIn this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input. This is shown below.\n\n\n\nInput\nOutput\nLogic\n\n\n\n\nS[0:1]\nOnboard Led 0\nXOR\n\n\nS[2:3]\nOnboard Led 1\nAND\n\n\n\\(48\\) Mhz Oscillator\nOnboard Led 2\n2.4 Hz Blinking\n\n\nS[0:6]\n7 Segment Display\nBinary Decoder\n\n\n\n\n\nHardware Setup\nI followed the Lab 1 guide for assembling and soldering my development board in addition to the interactive site.\n\n\n\n\nMCU and FPGA Development Board\n\n\n\n\n\nBoard Backside View\n\n\n\n\n\nRibbon Extender Connection\n\n\n\n\n\nCalculations\nAssuming our 7 Segment Display LEDs have a drop of 2V and we want to restrict the current flow through the display to less than 20 milliamps. Using Ohm’s Law: \\(V = IR\\) we can rearrange to solve for resistance: \\(R = \\frac{V}{I}\\). Then plugging in our values: \\(\\frac{[3.3 V - 2 V] - 0 V}{20 \\times 10^{\\3} A} = 65 \\Omega\\). So I will use a resistor larger than \\(65 \\Omega\\), the nearest size up stocked in the Engineering Stockroom being \\(68 \\Omega\\), restricting the current through the display to \\(19\\) mA of current.\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\nI created a testbench for each of the modules I made. The testbenches loads testvectors that simulate all of the combinational logic of switches and LED and 7 Segment Display outputs against each other to make sure the outputs are what I expect when the module is run. You can see below my waveforms generated from my 3 simulations\n\n\n\n\nTop Level Module\n\n\n\n\n\n\nLED Module\n\n\n\n\n\n7 Segment Display Module\n\n\n\n\nThe top level module ran 16 tests with 0 errors !\n\n\nHardware Testing\n\n\n\nOscilloscope Trace of led[2] pin 42\n\n\n\n\n\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”.\nCompiling the given code resulted in 1 error and 12 warnings: Error 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/abrah/onedrive/documents/lab1_ai/source/impl_1/lab1_ai.sv(21): instantiating unknown module SB_HFOSC. VERI-1063 [lab1_ai.sv:21]\nIt simply suggested I didn’t have the module installed but it was trying to access a oscillator not compatible with our board. I fixed the oscillator declaration for it then it compiled fine.\n\n\nResults\nAll lab requirements were met. The E155 development board is fully assembled and operational, except for a broken ribbon cable connector that needs replacement. The FPGA is programmed with synthesized Verilog, successfully driving the LEDs and 7-segment display as specified. Both simulation and hardware tests confirm correct operation, with the 7-segment display showing all digits clearly and equally bright."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "section": "",
    "text": "Overview\nTO-DO"
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab, the microcontroller and FPGA development board we will use for the continuation of this semester of E155 was soldered and assembled. We verified it was working correctly by uploading some demo code to make an onboard LED blink at \\(1\\) Hz.\nThe rest of the lab consisted of making some combinational logic to turn on onboard LEDs in addition to making another onboard LED blink at \\(2.4\\) Hz and more combinational logic to display a digit in a 7-Segment-Display depending on the binary input."
  },
  {
    "objectID": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-3-keypad-scanner",
    "href": "labs/labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-4-digital-audio",
    "href": "labs/labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-5-interrupts",
    "href": "labs/labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "href": "labs/labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface-learning",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface Learning\nTO-DO"
  },
  {
    "objectID": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs/labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\nTO-DO"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Hours spent on lab: 15 Hours\n\nHours procrastinated: 45 Hours :(\n\n\n\nOverview\nIn this lab, expanding on our 7-segment-display knowledge from Lab 1, we controlled a two digit 7-segment-display with the same pins via multiplexing the power pins based on the clock signal. Controlling each segment with independent combinational logic, we toggle between them fast enough to appear as if they are both independently running. Finally, we display the sum of the two numbers displayed on the digits as a binary sum in the form of LEDs.\n\n\nHardware Setup\nOur FPGA has 18 GPIO pins available for use. The two 7-segment-displays require 7 pins for each segment, and 2 pins for powering them (while an inverter chip could’ve been used, it would’ve been more to breadboard and the pin was available for use). 4 Input pins for the DiP switches and 5 output pins for the summation LEDs, so we utilized all available programmable pins on our FPGA. This is my breadboard:\n\n\n\nLab 2 Circuit Breadboard\n\n\n\n\nCalculations\n\nTransistor Current through the Base:\nThe drop of the diode in the transistor is \\(V_{BE} = 700 mV\\). Due to this drop, the Base is at \\(2.6 V\\) and the collector is at \\(3.3 V - 250 mV = 3.05 V\\). If our red 7-Segment-Display Diodes have a drop of \\(1.8V\\) … and a safe current into our FPGA is around \\(5 mA\\) so we can also see our diode light up. \\(\\frac{3.05 - 0}{5 * 10^{-3}} = 610 \\Omega\\). So for our power driving resistors … we can safely use a \\(610 \\Omega\\) Resistor or larger.\n\n\nDriving single LEDs\nSince our single red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.3 V - 1.8 V}{10*10^{-3} A} = 100 \\Omega\\).\n\n\nDriving 7-Segment-Display\nSince our 7-Segment-Display red LEDs have a drop of about \\(1.8 V\\), \\(\\frac{3.1 V - 1.8 V}{5*10^{-3} A} = 260 \\Omega\\). (From \\(3.1 V\\) due to Transistor Collector).\n\n\n\nMethods\nI broke up the required tasks into different Verilog modules. In the following block diagram you can see each of my modules and how they fit together.\n\n\n\nBlock Diagram\n\n\nThe modules can be found here in my github.\n\n\nSchematic\nThe schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display.\n\n\n\nSchematic\n\n\n\n\nSimulations\n\n\nAI Prototype\nI used Gemini’s 2.5-Pro model for this section of the assignment.\nI prompted the AI with: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”.\nThe AI-generated code was similar to my approach, splitting the design into a top-level module, a seven-segment decoder, and a multiplexing controller. It also instantiated a high-speed oscillator for timing, which I had to fix in my own implementation due to synthesis errors. The AI’s code provided a good reference for structuring the multiplexing clock logic and handling two sets of input bits. I can appreciate how it does everything in hex too to make things a bit more readable.\nFor the next prompt: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” It again did a good job that compiled and the logic looked like it would perform well upon upload.\n\n\nResults\nAll lab requirements were met. Human eye cannot tell the flickering of my multiplexing at 60Hz. All combinations work with little to no bleed of lights or colors."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Hours spent on lab: 9 Hours\n\nHours procrastinated: \\(e^\\inf\\) Hours\n\n\n\nOverview\nIn this lab, we shift away from Hardware Description Language and our FPGA. We begin to make some set-up files for our Microcontroller STM32L432KCUx to access its internal clock, GPIO clocks, and Timer clocks to generate electrical pulses and delays in the form of square waves.\n\n\n\n\n\n\n\n\n\n\n\n\nHardware Setup\nI followed figure 9-5 on the LM386 datasheet using the audio amplifier. To create my breadboard:\n\n\n\nBreadboard\n\n\n\n\nSchematic\nThe schematic for the circuit includes the MCU, Piano switches, Push-Buttons, and the LM386 Audio Amplifier.\n\n\n\nSchematic\n\n\n\n\nCalculations\n\nDelay\nGiven the following formulas:\n\n\\(f_{timer}=\\frac{f_{clk}}{PSC+1}\\)\n\\(f_{reload}=\\frac{f_{timer}}{ARR+1}\\)\n\\(T=\\frac{PSC+1}{f_{clk}}\\times (ARR+1)\\)\n\nHardcoding PSC for delay as 2500, we can use our first equation \\(f_{timer}=\\frac{80 * 10^6 Hz}{2501} \\approx 31987.2 Hz\\). We can then use our 3rd equation to see our minimum and maximum delay depending on what \\(ARR\\) is set as as the incrementer.\nMinimum (ARR = 1): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (2) \\approx 62.5 \\mu s\\).\nMaximum (ARR = 65635 = 0xFFFF): \\(T=\\frac{2501}{80 * 10^6 Hz}\\times (65535) \\approx 2.05 s\\).\n\n\n\nPulse Width Modulation\nGiven the following formula:\n\n\\(f_{pwm}=\\frac{f_{clk}}{(PSC+1)(ARR+1)}\\)\n\nMinimum (largest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{65535^2} \\approx 18.627 mHz\\)\nMaximum (smallest PSC and ARR): \\(f_{pwm}=\\frac{80 * 10^6 Hz}{2} = 40 MHz\\)\nSo let’s go through some examples to see how accurate our production is even with the rounding and integer division taking place.\n78 Hz (Eb2):\n\\(D = \\frac{80*10^6}{78} \\approx 1025641.03\\).\nSo my code would choose a PSC Value of \\(\\frac{1025641.03}{65536} - 1 \\approx 15.65 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(16 - 1 = 15\\).\nIt would then calculate a ARR Value of \\(\\frac{1025641.03}{15 + 1} \\approx 64102.56\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(64103\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{16 * 64103} \\approx 77.995\\).\nWe have an error of \\(\\frac{77.995 - 78}{78} \\approx -0.0064 \\%\\).\n440 Hz (A4):\n\\(D = \\frac{80*10^6}{440} \\approx 181818.\\overline{18}\\).\nSo my code would choose a PSC Value of \\(\\frac{181818.\\overline{18}}{65536} - 1 \\approx 2.8 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(3 - 1 = 2\\).\nIt would then calculate a ARR Value of \\(\\frac{181818.\\overline{18}}{2 + 1} \\approx 60606.06\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(60606\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{181818} = 440.00044\\).\nWe have an error of \\(\\frac{440.00044 - 440}{440} = 0.0001 \\%\\).\n1568 Hz (G6):\n\\(D = \\frac{80*10^6}{1568} \\approx 51020.41\\).\nSo my code would choose a PSC Value of \\(\\frac{51020.41}{65536} - 1 \\approx 0.77 - 1\\).\nI use ceil to round numbers with a decimal of 0.5 or more to the next largest integer so we end up getting \\(1 - 1 = 0\\).\nIt would then calculate a ARR Value of \\(\\frac{51020.41}{0 + 1} \\approx 51020.41\\).\nI use round to bring down numbers with a decimal of less than 0.5 to the next smallest integer getting us \\(51020\\).\nThen calculating \\(f_{clk} = \\frac{80*10^6 Hz}{PSC * ARR} = \\frac{80*10^6 Hz}{51021} \\approx 1567.97\\).\nWe have an error of \\(\\frac{1567.97 - 1568}{1568} \\approx -0.0019 \\%\\).\n\n\n\nVerification\n\n\n\n\n\n500 Hz Trace\n\n\nPercent Error = \\(\\frac{497.22 - 500}{500} \\approx 0.56 \\%\\) \n\n\n\n\n\n\n1000 Hz Trace\n\n\nPercent Error = \\(\\frac{994.1 - 1000}{1000} \\approx 0.59 \\%\\)\n\n\n\n\n\n\n5000 Hz Trace\n\n\nPercent Error = \\(\\frac{4973.7 - 5000}{5000} \\approx 0.53 \\%\\)\n\n\n\n\n\nAI Prototype\nThis week I prompted Claude AI with “What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?”. For additional context, I was able to upload the Datasheet and Reference Manual to the AI so it could potentially go through and not hallucinate registers.\n\n\nClaude AI Response Summary\n\n\nRecommended Timer: TIM2 (32-bit general-purpose timer)\n\n\n\nBest for 220Hz-1kHz range due to 32-bit counter flexibility\n\n\n4 channels available for PWM output\n\n\nEasy GPIO mapping via alternate functions\n\n\n\nKey Formula:\n\nf_output = f_timer / ((PSC + 1) × (ARR + 1))\n\nWhere f_timer is typically 80 MHz, PSC is the prescaler value, and ARR is the auto-reload value.\n\n\nEssential Registers:\n\n\n\nTIMx_PSC - Prescaler (divides clock)\n\n\nTIMx_ARR - Auto-reload register (defines period)\n\n\nTIMx_CCRx - Capture/compare (sets duty cycle)\n\n\nTIMx_CCMR - Set to PWM mode (OCxM = 110 or 111)\n\n\nTIMx_CCER - Enable channel output\n\n\nTIMx_CR1 - Enable counter\n\n\n\nExample (440Hz): With 80 MHz clock, PSC=79, ARR=2272 gives 440.05 Hz\n\n\nGPIO Connection: Configure pin alternate function per datasheet tables (e.g., PA0 = TIM2_CH1 with AF1)\n\n\nI think it did a good job with this response. From my understanding of the reference manual, TIM2 is one of the more robust timers on our microcontroller and could definetley be used to produce a PWM signal.\n\n\nConclusion\nThe design worked as intended. You are able to trigger the given song: Fur Elise by the press of a button, and trigger my song of choice: Un Sospiro by clicking a switch."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/idna-3.10.dist-info/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "href": "e155-portfolio/lib/python3.13/site-packages/pyzmq-27.0.2.dist-info/licenses/LICENSE.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  }
]