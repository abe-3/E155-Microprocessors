<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 7: The Advanced Encryption Standard – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project/project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#simulation-verification" id="toc-simulation-verification" class="nav-link" data-scroll-target="#simulation-verification">Simulation Verification</a></li>
  <li><a href="#hardware-verification" id="toc-hardware-verification" class="nav-link" data-scroll-target="#hardware-verification">Hardware Verification</a></li>
  <li><a href="#ai-prototype" id="toc-ai-prototype" class="nav-link" data-scroll-target="#ai-prototype">AI Prototype</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 7: The Advanced Encryption Standard</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="hours-spent-on-lab-12-hours" class="level4">
<h4 class="anchored" data-anchor-id="hours-spent-on-lab-12-hours">Hours spent on lab: 12 Hours</h4>
</section>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>After learning SPI Communication in Lab 6, we are returning back to System Verilog and our FPGA to incorporate our new learned skill to have them communicate. Our Microcontroller will act as the host, sending a 128-bit plaintext message and a 128-bit key via SPI. Our FPGA performs a very complex sequence of operations to function as a 128-bit AES encryption hardware accelerator. The FPGA receives the inputs, computes the encryption, and transmits the resulting ciphertext back to the microcontroller for verification.</p>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<p>The block diagram for the hardware involves a top-level module (aes_starter) which instantiates the provided SPI interface and the custom aes_core module.</p>
<p>Due to synthesis constraints, the logic is too large to implement all encryption rounds as one giant block of combinational logic. Therefore, the aes_core must be designed to perform the rounds sequentially. This architecture is partitioned into a datapath and a controller.</p>
<p>Controller: A Finite State Machine (FSM) that generates the control signals to manage the flow of data through the datapath. It sequences the 10 rounds of encryption, asserts the correct multiplexer select signals, and manages register enables. The FSM must account for the one-cycle latency of the sbox synchronous RAM lookup.</p>
<p>Datapath: Consists of registers to hold the 128-bit intermediate state and the round key. It includes multiplexers and the combinational logic blocks for the four main AES transformations:</p>
<ul>
<li>sbox: The provided byte-substitution module (using sbox.txt).</li>
<li>ShiftRows: A combinational wire-shuffling module.</li>
<li>MixColumns: The provided Galois field arithmetic module.</li>
<li>AddRoundKey: A bitwise XOR operation.</li>
</ul>
The controller dictates when the state register is loaded and which transformation’s output is fed back as the next input, iterating until the final ciphertext is produced and ready for SPI transmission.
<figure style="flex:1 1 30%; text-align:center;" class="figure">
<img src="images/block_diagram.jpeg" alt="Block Diagram" style="width:100%; border-radius:8px;" class="figure-img">
<figcaption>
Block Diagram
</figcaption>
</figure>
</section>
<section id="simulation-verification" class="level3">
<h3 class="anchored" data-anchor-id="simulation-verification">Simulation Verification</h3>
For my 4 custom modules to implement AES Encryption, you can see my verification of each of them:
<style>
  .waveform-figure {
    margin-bottom: 20px;
    text-align: center;
  }

  .waveform-figure img {
    max-width: 100%;
    height: auto;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: zoom-in;
  }

  .waveform-figure figcaption {
    margin-top: 5px;
    font-size: 0.9em;
    color: #555;
  }

  /* Layout containers */
  .waveform-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
  }

  .waveform-row.top img {
    max-width: 600px; /* Large top images */
  }

  .waveform-row.bottom img {
    max-width: 300px; /* Smaller bottom images */
  }
</style>
<!-- Top two large images -->
<div class="waveform-row top">
<figure class="waveform-figure figure">
<a href="images/aes_spi_waves.png" target="_blank"> <img src="images/aes_spi_waves.png" alt="Top Level SPI Testbench" class="figure-img"> </a>
<figcaption>
Top Level SPI Testbench
</figcaption>
</figure>
<figure class="waveform-figure figure">
<a href="images/aes_core_waves.png" target="_blank"> <img src="images/aes_core_waves.png" alt="Main Core Module Testbench" class="figure-img"> </a>
<figcaption>
Main Core Module Testbench
</figcaption>
</figure>
</div>
<!-- Bottom three smaller images -->
<div class="waveform-row bottom">
<figure class="waveform-figure figure">
<a href="images/core_key_waves.png" target="_blank"> <img src="images/core_key_waves.png" alt="Key Expansion Testbench" class="figure-img"> </a>
<figcaption>
Key Expansion Testbench
</figcaption>
</figure>
<figure class="waveform-figure figure">
<a href="images/core_round_logic_waves.png" target="_blank"> <img src="images/core_round_logic_waves.png" alt="Round Logic Testbench" class="figure-img"> </a>
<figcaption>
Round Logic Testbench
</figcaption>
</figure>
<figure class="waveform-figure figure">
<a href="images/core_subbytes_waves.png" target="_blank"> <img src="images/core_subbytes_waves.png" alt="Subbytes Testbench" class="figure-img"> </a>
<figcaption>
Subbytes Testbench
</figcaption>
</figure>
</div>
</section>
<section id="hardware-verification" class="level3">
<h3 class="anchored" data-anchor-id="hardware-verification">Hardware Verification</h3>
<p>Connecting the SPI data pins to the oscilloscope logic analyzer and running a SPI function like our temperature read function, we can visualize the command signals, SPI output, and encrypted words being sent to and from the FPGA.</p>
<table style="width:100%; border-collapse: collapse;">
<tbody><tr style="border: none;">
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_1.png" target="_blank"> <img src="images/logic_analyzer_1.png" alt="Logic Analyzer Trace 1" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 1
</figcaption>
</figure>
</td>
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_2.png" target="_blank"> <img src="images/logic_analyzer_2.png" alt="Logic Analyzer Trace 2" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 2
</figcaption>
</figure>
</td>
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_3.png" target="_blank"> <img src="images/logic_analyzer_3.png" alt="Logic Analyzer Trace 3" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 3
</figcaption>
</figure>
</td>
</tr>
<tr style="border: none;">
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_4.png" target="_blank"> <img src="images/logic_analyzer_4.png" alt="Logic Analyzer Trace 4" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 4
</figcaption>
</figure>
</td>
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_5.png" target="_blank"> <img src="images/logic_analyzer_5.png" alt="Logic Analyzer Trace 5" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 5
</figcaption>
</figure>
</td>
<td style="width: 33.33%; text-align: center; padding: 10px; border: none;">
<figure class="figure">
<a href="images/logic_analyzer_6.png" target="_blank"> <img src="images/logic_analyzer_6.png" alt="Logic Analyzer Trace 6" style="width:100%; border-radius:8px; cursor: zoom-in;" class="figure-img"> </a>
<figcaption>
Logic Analyzer Trace 6
</figcaption>
</figure>
</td>
</tr>
</tbody></table>
</section>
<section id="ai-prototype" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h3>
<p>This week I prompted ChatGPT with “Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.” For additional context, I provided the NIST AES Specifications.</p>
<div style="max-height: 400px; overflow-y: auto; border: 1px solid #ccc; border-radius: 8px; padding: 10px; background-color: #f8f9fa;">
<pre><code class="verilog">
// aes_keyexp_round.sv
// Combinational per-round AES-128 KeyExpansion
// Assumes SUBWORD and ROTWORD are provided elsewhere.
// Produces next 128-bit round key from previous 128-bit round key and round number.
//
// Reference: FIPS-197 Algorithm 2 (KEYEXPANSION) and Table 5 (Rcon). 

module aes_keyexp_round #(
    parameter int AES_NK = 4   // only AES_NK==4 (AES-128) is implemented here
) (
    input  logic [127:0] prev_key,   // previous round key: {w0, w1, w2, w3} (big-endian word order)
    input  logic [3:0]   round_idx,  // round index (1..10 for AES-128). round_idx==0 -&gt; next_key = prev_key (default)
    output logic [127:0] next_key
);

    // Rcon table (words): index 1..10 valid for AES-128
    localparam logic [31:0] RCON [1:10] = '{
        32'h01000000, 32'h02000000, 32'h04000000, 32'h08000000,
        32'h10000000, 32'h20000000, 32'h40000000, 32'h80000000,
        32'h1b000000, 32'h36000000
    };

    // Word extraction (big-endian grouping)
    logic [31:0] w0, w1, w2, w3;
    assign {w0, w1, w2, w3} = prev_key; // prev_key[127:96] = w0, [95:64]=w1, [63:32]=w2, [31:0]=w3

    // External helpers (assumed implemented elsewhere).
    // Provide prototypes so synthesis/simulation tools know the calls exist.
    // Replace these with module/task calls if your implementation exposes them differently.
    function automatic logic [31:0] SUBWORD(input logic [31:0] in_word);
        // implemented elsewhere; prototype only
    endfunction

    function automatic logic [31:0] ROTWORD(input logic [31:0] in_word);
        // implemented elsewhere; prototype only
    endfunction

    // Internal temps / outputs
    logic [31:0] temp, nw0, nw1, nw2, nw3;

    // Combinational expansion logic (AES-128/Nk==4)
    always_comb begin
        // Default: pass-through if round_idx == 0
        if (AES_NK != 4) begin
            // Not implemented for Nk != 4 in this module.
            // Output zeros to make behavior deterministic; caller should not use this for Nk != 4.
            next_key = '0;
        end else if (round_idx == 0) begin
            next_key = prev_key;
        end else begin
            // temp = SUBWORD(ROTWORD(w3)) XOR Rcon[round_idx]
            // round_idx range check: clamp 1..10 for AES-128
            int rindex = (round_idx &lt; 1) ? 1 : (round_idx &gt; 10) ? 10 : round_idx;
            temp = SUBWORD(ROTWORD(w3)) ^ RCON[rindex];

            // w4 = w0 ^ temp
            nw0 = w0 ^ temp;
            // w5 = w1 ^ w4
            nw1 = w1 ^ nw0;
            // w6 = w2 ^ w5
            nw2 = w2 ^ nw1;
            // w7 = w3 ^ w6
            nw3 = w3 ^ nw2;

            next_key = {nw0, nw1, nw2, nw3};
        end
    end
endmodule
</code></pre>
</div>
<p>The AI did pretty bad this week. The logic and sequence makes sense, however, it already is far too big to upload to our Upduino FPGA, likely because of the 96 XOR operations happening in parallel and the large functions it is declaring.</p>
We can continue and see how the same LLM will perform for the same task with a new prompt: “Write SystemVerilog HDL to implement the following logic:
<div style="max-height: 400px; overflow-y: auto; border: 1px solid #ccc; border-radius: 8px; padding: 10px; background-color: #0fffff;">
<pre><code class="verilog">
i = 0
while i &lt; Nk do
    w[i] &lt;- key[4*i..4*i+3]
    i &lt;- i+1
end while
while i &lt;= 4 * Nr + 3 do
    temp &lt;- w[i-1]
    if i mod Nk = 0 then
        temp &lt;- module1(module2(temp)) (+) Rcon[i/Nk]
    else if Nk &gt; 6 and i mod Nk = 4 then
        temp &lt;- module1(temp)
    end if
    w[i] &lt;- w[i-Nk] (+) temp
    i &lt;- i + 1
end while
return w
</code></pre>
</div>
<p>Assume module1 and module2 are existing modules that can be instantiated. (+) refers to XOR. Unwrap the loop in the provided pseudo code so it uses the previous iterations output to generate the new iteration.</p>
<p>Do not use any existing knowledge of the AES specifications in your answer.”</p>
<p>It produces the following:</p>
<div style="max-height: 400px; overflow-y: auto; border: 1px solid #ccc; border-radius: 8px; padding: 10px; background-color: #f8f9fa;">
<pre><code class="system-verilog">
module KeyExpansion #(
    parameter int Nk = 4,              // number of key words
    parameter int Nr = 10              // number of rounds
)(
    input  logic [32*Nk-1:0] key,      // input key (Nk words)
    input  logic [31:0]       Rcon   [0:((4*Nr+3)/Nk)],
    output logic [32*(4*Nr+4)-1:0] w   // expanded key words
);

    // Intermediate array of words
    logic [31:0] w_array [0:(4*Nr+3)];
    logic [31:0] temp;
    logic [31:0] mod1_out, mod2_out;

    // Modules (instantiated once, used combinationally)
    module1 u_mod1 (.in(temp), .out(mod1_out));
    module2 u_mod2 (.in(temp), .out(mod2_out));

    // Initial Nk words come directly from key
    genvar i;
    generate
        for (i = 0; i &lt; Nk; i++) begin
            assign w_array[i] = key[32*i +: 32];
        end
    endgenerate

    // Iteratively expand key schedule
    always_comb begin
        for (int j = Nk; j &lt;= 4*Nr + 3; j++) begin
            temp = w_array[j-1];
            if ((j % Nk) == 0) begin
                temp = mod1_out ^ Rcon[j/Nk];
            end
            else if ((Nk &gt; 6) &amp;&amp; ((j % Nk) == 4)) begin
                temp = mod1_out;
            end
            w_array[j] = w_array[j-Nk] ^ temp;
        end
    end

    // Flatten w_array to output vector
    generate
        for (i = 0; i &lt;= 4*Nr + 3; i++) begin
            assign w[32*i +: 32] = w_array[i];
        end
    endgenerate
endmodule
</code></pre>
</div>
<p>Similarily to last time, this module is extremely expensive. ChatGPT is mindlessly running a lot of for loops many times more than necessary creating a lot fo extra hardware.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>The design worked as intended. Our top level testbench passes with no errors and successfully returns the decrypted word.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/abe-3\.github\.io\/E155-Microprocessors\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>