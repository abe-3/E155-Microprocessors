<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Project Proposal – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project/project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#specifications" id="toc-specifications" class="nav-link" data-scroll-target="#specifications">Specifications</a></li>
  <li><a href="#microcontroller-integration" id="toc-microcontroller-integration" class="nav-link" data-scroll-target="#microcontroller-integration">Microcontroller Integration</a></li>
  <li><a href="#fpga-integration" id="toc-fpga-integration" class="nav-link" data-scroll-target="#fpga-integration">FPGA Integration</a></li>
  <li><a href="#calculations" id="toc-calculations" class="nav-link" data-scroll-target="#calculations">Calculations</a></li>
  <li><a href="#bill-of-materials-budget" id="toc-bill-of-materials-budget" class="nav-link" data-scroll-target="#bill-of-materials-budget">Bill of Materials / Budget</a></li>
  <li><a href="#project-timeline-weeks-815" id="toc-project-timeline-weeks-815" class="nav-link" data-scroll-target="#project-timeline-weeks-815">Project Timeline — Weeks 8–15</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#action-items" id="toc-action-items" class="nav-link" data-scroll-target="#action-items">Action Items</a></li>
  <li><a href="#task-division" id="toc-task-division" class="nav-link" data-scroll-target="#task-division">Task Division</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project Proposal</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>DDRUM is a four-pad rhythm game in the spirit of DDR and Guitar Hero. Notes descend in four lanes on a display while a song plays. The player strikes one of four drum pads on the beat, and the system scores accuracy as Perfect, Good, or Miss with real-time visual feedback and a running score/combo.</p>
<p>The STM32L432 (Nucleo-L432KCU) acts as the central brain and system coordinator: it reads <code>.wav</code> files from an SD card, performs an <strong>offline FFT-based beat-detection analysis</strong> (using the <strong>CMSIS-DSP</strong> library) to auto-generate a beatmap, streams audio via <strong>I2S+DMA</strong> to a DAC, and drives the <strong>LED Matrix</strong>. The iCE40UP5K (UPduino v3.1) FPGA acts as a <strong>high-precision I/O accelerator</strong>: it captures drum pad hits with nanosecond accuracy, timestamps them, and stores them in a <strong>FIFO</strong> for the MCU to read. The result is a responsive, low-latency game that cleanly divides responsibilities: MCU for all logic, audio, and graphics; FPGA for time-critical hit detection. Success is defined as smooth 30+ FPS visuals on the Matrix, consistent audio-visual synchronization, accurate beat-detection on at least one song, consistent and accurate pad detection via the FPGA, and a real-time scoring system with a leaderboard. The design uses both the MCU and FPGA in roles beyond prior labs and introduces non-trivial new hardware: an I2S DAC, piezo sensor inputs, and an SD card reader.</p>
</section>
<section id="specifications" class="level3">
<h3 class="anchored" data-anchor-id="specifications">Specifications</h3>
<ul class="task-list">
<li><label><input type="checkbox"><strong>Frame Rate:</strong> 30+ FPS steady output on 60 x 60 LED Matrix</label></li>
<li><label><input type="checkbox"><strong>Audio Playback:</strong> <code>.wav</code> file playback via I2S DAC with DMA</label></li>
<li><label><input type="checkbox"><strong>Audio Analysis:</strong> Successful offline beat-detection (bass/snare/cymbal) using the <strong>CMSIS-DSP FFT</strong> library.</label></li>
<li><label><input type="checkbox"><strong>Random Mode:</strong> A “survival” mode that uses the <strong>TRNG</strong> (True Random Number Generator) peripheral to auto-generate an endless stream of notes.</label></li>
<li><label><input type="checkbox"><strong>Input Detection:</strong> Four piezo sensors captured by the FPGA with sub-microsecond precision.</label></li>
<li><label><input type="checkbox"><strong>Latency Budget:</strong> End-to-end pad hit (FPGA) to MCU-read and scoring &lt;1 ms.</label></li>
<li><label><input type="checkbox"><strong>Scoring Windows:</strong> Perfect ±35 ms, Good ±75 ms, Miss &gt;±120 ms.</label></li>
<li><label><input type="checkbox"><strong>Visual Features:</strong> Four color-coded lanes, falling notes, combo counter, and hit flash overlay on the TFT.</label></li>
<li><label><input type="checkbox"><strong>Memory Reading:</strong> Reads music files, saves beatmaps, and reads/writes a persistent high-score leaderboard from an SD card using <strong>FatFs</strong>.</label></li>
<li><label><input type="checkbox"><strong>Target Success Criteria:</strong> Smooth visuals, accurate scoring, synchronized audio, and a full playable song with consistent performance.</label></li>
</ul>
</section>
<section id="microcontroller-integration" class="level3">
<h3 class="anchored" data-anchor-id="microcontroller-integration">Microcontroller Integration</h3>
<p>The Nucleo-L432 provides the master clock (SysTick) for the entire system. It is responsible for all major logic. First, it implements a <strong>FAT file system</strong> (FatFs) to read <code>.wav</code> files from an SD card. In an “analysis” phase, it runs the <strong>CMSIS-DSP library’s FFT</strong> functions on the audio data to detect energy spikes in low/mid/high frequency bins, which it translates into a beatmap file (e.g., bass=pad1, snare=pad2) and saves back to the SD card. Second, during gameplay, it reads the <code>.wav</code> file again, streaming it via <strong>I2S and DMA</strong> to an external DAC for high-quality audio. Third, it simultaneously reads the generated beatmap and drives the game visuals (note highway, score) to an <strong>SPI TFT display</strong>. Fourth, it implements a “survival mode” using the <strong>TRNG</strong> peripheral to generate an unpredictable note stream. Finally, it runs the game logic, reading hit timestamps from the FPGA’s FIFO over SPI and comparing them to the master clock to determine score (Perfect/Good/Miss). This combination of DSP libraries, I2S+DMA, TRNG, and FatFs is well beyond prior labs.</p>
</section>
<section id="fpga-integration" class="level3">
<h3 class="anchored" data-anchor-id="fpga-integration">FPGA Integration</h3>
<p>The iCE40UP5K is used as a <strong>high-speed, parallel I/O accelerator</strong>. Its sole task is to solve the problem of missed inputs. The four piezo drum pads (after passing through a simple comparator circuit) feed into the FPGA. The FPGA implements four <strong>high-precision timestamping modules</strong> in hardware. When a pad is hit, the FPGA captures the <em>exact</em> time of the rising edge (relative to its own clock) and stores this hit event (e.g., 4-bits for “lane” + 32-bits for “time”) into a <strong>hardware FIFO (First-In, First-Out) buffer</strong>. The MCU can then read from this FIFO over SPI at its own leisure (e.g., once per game loop). This design completely decouples the MCU’s main logic from the time-critical, nanosecond-precision task of input capture. This I/O co-processing, timestamping, and FIFO buffering is a new application of the FPGA.</p>
<p>I believe the <strong>beat-detection algorithm</strong> will be the riskiest element of our design; tuning the FFT and onset detection to create a “fun” and accurate beatmap from an arbitrary song is a significant DSP challenge.</p>
</section>
<section id="calculations" class="level3">
<h3 class="anchored" data-anchor-id="calculations">Calculations</h3>
<p><strong>FFT Analysis.</strong> Using the CMSIS-DSP library, a 1024-point real FFT on the Cortex-M4 (with FPU) is highly optimized. Analyzing a full 3-minute, 44.1kHz song will be an “offline” process (e.g., 10-15 seconds) shown on a loading screen. <strong>Scroll mapping.</strong> At 30 FPS each frame advances by 33.3 ms. If we want a note to travel 240 px in 1500 ms, the scroll rate is <span class="math inline">\(v = \frac{240}{1500} = \frac{0.16 px}{ms}\)</span>, so the per-frame step is <span class="math inline">\(\Delta y \approx 5\)</span> px. <strong>SPI bandwidth.</strong> Preloading a beatmap (~10-20 KB) is fast. Runtime traffic is minimal: the MCU just needs to send a “read” command to the FPGA’s FIFO over SPI, which can run at 8–12 MHz. <strong>Latency budget.</strong> Pad analog to digital logic &lt; 100 µs; FPGA capture-to-FIFO &lt; 1 µs. MCU SPI read to game logic &lt; 100 µs. The end-to-end <em>detection</em> latency is well under 1 ms. The visual feedback is limited only by the TFT’s refresh rate (33 ms). This leaves ample room for scoring windows at <span class="math inline">\(\pm 35/ \pm 75\)</span> ms. <strong>Power and levels.</strong> Logic runs at 3.3 V; I2S DAC and audio at 3.3 V or 5 V with a common ground.</p>
</section>
<section id="bill-of-materials-budget" class="level3">
<h3 class="anchored" data-anchor-id="bill-of-materials-budget">Bill of Materials / Budget</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th>Part / ID</th>
<th>Qty</th>
<th>Source</th>
<th>Est. Price</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>FPGA board</strong></td>
<td>UPduino v3.1 (iCE40UP5K)</td>
<td>1</td>
<td>Provided</td>
<td>$0.00</td>
<td></td>
</tr>
<tr class="even">
<td><strong>MCU board</strong></td>
<td>Nucleo-L432KCU (STM32L432KC)</td>
<td>1</td>
<td>Provided</td>
<td>$0.00</td>
<td></td>
</tr>
<tr class="odd">
<td>Piezo discs (27–35 mm)</td>
<td>e.g., ABT-402-RP or generic</td>
<td>4</td>
<td></td>
<td>$4.00</td>
<td>Drum sensors ($1.00 each)</td>
</tr>
<tr class="even">
<td>Comparator (optional)</td>
<td>LM393 or similar</td>
<td>2-4</td>
<td></td>
<td>$2.00</td>
<td>Signal conditioning for FPGA</td>
</tr>
<tr class="odd">
<td>AFE passives</td>
<td>10k/100k resistors, 100 nF caps (1%)</td>
<td>set</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Divider / RC</td>
</tr>
<tr class="even">
<td>Momentary buttons</td>
<td>12 mm tactiles</td>
<td>3</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Start / Select / Pause</td>
</tr>
<tr class="odd">
<td><strong>I2S DAC Module</strong></td>
<td><strong>MAX98357A</strong> or PCM5102</td>
<td>1</td>
<td></td>
<td>$7.00</td>
<td>Audio output (New)</td>
</tr>
<tr class="even">
<td><strong>microSD Card Module</strong></td>
<td>e.g., Adafruit 254</td>
<td>1</td>
<td></td>
<td>$5.00</td>
<td>Music/Beatmap/Leaderboard (New)</td>
</tr>
<tr class="odd">
<td><strong>SPI TFT Display</strong></td>
<td><strong>2.8” ILI9341</strong> (320x240)</td>
<td>1</td>
<td></td>
<td>$15.00</td>
<td>Game Display (New)</td>
</tr>
<tr class="even">
<td>Perfboard / wiring</td>
<td>—</td>
<td>—</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Interconnects</td>
</tr>
<tr class="odd">
<td>Enclosure materials</td>
<td>—</td>
<td>—</td>
<td>Makerspace</td>
<td>$0.00</td>
<td>Plywood + 3D printer filament</td>
</tr>
</tbody>
</table>
<p><strong>Subtotal (purchased items): $33.00</strong></p>
<p><em>(This total is well within the $50 budget.)</em></p>
<hr>
</section>
<section id="project-timeline-weeks-815" class="level3">
<h3 class="anchored" data-anchor-id="project-timeline-weeks-815">Project Timeline — Weeks 8–15</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Week</th>
<th>Date</th>
<th>Scheduled Topics</th>
<th>Deliverables</th>
<th>Project Milestone</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>8</strong></td>
<td>Oct 13</td>
<td><strong>Fall Break — No Class</strong>; Proposal Debriefs</td>
<td><a href="https://hmc-e155.github.io/project/">Project Proposal</a></td>
<td>—</td>
</tr>
<tr class="even">
<td><strong>9</strong></td>
<td>Oct 20</td>
<td>AES Lecture &amp; FPGA Workshop</td>
<td><a href="https://hmc-e155.github.io/lab/lab6/">Lab 6</a></td>
<td>(A) MCU: Play audio from SD card via I2S+DMA. (S) FPGA: Implement piezo hit capture &amp; FIFO.</td>
</tr>
<tr class="odd">
<td><strong>10</strong></td>
<td>Oct 27</td>
<td>Graphics, Displays, Motors &amp; Speakers</td>
<td><a href="https://hmc-e155.github.io/lab/lab7/">Lab 7</a></td>
<td>(A) MCU: Drive TFT display. Read hit timestamps from FPGA over SPI. (S) Integrate piezo-to-FPGA path.</td>
</tr>
<tr class="even">
<td><strong>11</strong></td>
<td>Nov 3</td>
<td>Design Review Presentations (T/Th)</td>
<td>Design Review Presentation &amp; Memo</td>
<td>Demo: Hitting a pad makes a sprite appear on the TFT, while music plays.</td>
</tr>
<tr class="odd">
<td><strong>12</strong></td>
<td>Nov 10</td>
<td>Intro to RTOS; Direct Memory Access</td>
<td>—</td>
<td>Develop v1.0 of offline FFT beat-detection (CMSIS-DSP) on MCU.</td>
</tr>
<tr class="even">
<td><strong>13</strong></td>
<td>Nov 17</td>
<td>Project Status Report &amp; Demo; Connectors</td>
<td>Project Status Reports &amp; Demo</td>
<td>Demo working game with auto-generated beatmap and scoring.</td>
</tr>
<tr class="odd">
<td><strong>14</strong></td>
<td>Nov 24</td>
<td>FFT Lecture; <strong>Thanksgiving — No Class (Th)</strong></td>
<td>—</td>
<td>Implement Leaderboard. Implement TRNG random mode. Debugging/tuning.</td>
</tr>
<tr class="even">
<td><strong>15</strong></td>
<td>Dec 4</td>
<td>Digital Signal Processing; Special Topics / Guest Lecture</td>
<td>Project Checkoffs, Report, Demo Day</td>
<td><strong>Win or Die</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<p><em>(The previous block diagram is no longer valid. This new architecture is as follows:)</em></p>
<ol type="1">
<li><strong>Inputs:</strong> Four <strong>Piezo Sensors</strong> connect to the <strong>FPGA</strong>.</li>
<li><strong>FPGA (I/O Accelerator):</strong> The FPGA’s <strong>Hit Detection + FIFO</strong> module communicates over <strong>SPI</strong> to the <strong>MCU</strong>.</li>
<li><strong>MCU (The Brain):</strong>
<ul>
<li>Reads/Writes to the <strong>SD Card Module</strong> (FatFs).</li>
<li>Drives the <strong>SPI TFT Display</strong>.</li>
<li>Streams audio to the <strong>I2S DAC Module</strong>.</li>
<li>Uses <strong>TRNG</strong> and <strong>CMSIS-DSP</strong> libraries.</li>
</ul></li>
<li><strong>Outputs:</strong> The <strong>I2S DAC</strong> outputs to a speaker/headphones. The <strong>TFT</strong> displays the game.</li>
</ol>
</section>
<section id="action-items" class="level3">
<h3 class="anchored" data-anchor-id="action-items">Action Items</h3>
<ul>
<li><label><input type="checkbox"><strong>Finalize Audio Path (MCU side)</strong> – Implement SD card (FatFs) file reading and I2S+DMA streaming of <code>.wav</code> files to the DAC.</label></li>
<li><label><input type="checkbox"><strong>Develop Pad Detection (FPGA side)</strong> – Build piezo sensor circuit and implement FPGA hardware for hit timestamping and FIFO.</label></li>
<li>[S] <strong>Implement Beat-Detection (MCU side)</strong> – Integrate CMSIS-DSP library and develop an FFT-based algorithm to auto-generate beatmaps.</li>
<li><label><input type="checkbox"><strong>SPI Communication Protocol</strong> – Define and implement the simple “read from FIFO” SPI protocol.</label></li>
<li><label><input type="checkbox"><strong>Game Logic (MCU side)</strong> – Develop the game loop, scoring logic, and leaderboard system.</label></li>
<li><label><input type="checkbox"><strong>Graphics (MCU side)</strong> – Write drivers for the SPI TFT to render the note highway, score, and hit flashes.</label></li>
<li><label><input type="checkbox"><strong>TRNG Mode</strong> – Use the TRNG peripheral to create a “survival” or “random” game mode.</label></li>
<li><label><input type="checkbox"><strong>Mechanical Integration</strong> – Assemble four-pad drum enclosure.</label></li>
<li><label><input type="checkbox"><strong>System Integration Test</strong> – Synchronize audio, visuals, and pad timing; validate scoring.</label></li>
<li><label><input type="checkbox"><strong>Final Debug and Polish</strong> – Tune FFT algorithm, scoring windows, and prepare final demo.</label></li>
</ul>
</section>
<section id="task-division" class="level3">
<h3 class="anchored" data-anchor-id="task-division">Task Division</h3>
<ul>
<li><strong>Abe:</strong> MCU code (FFT/Beat-detection, game logic, scoring, TRNG mode), Mechanical design (drum pad housing)</li>
<li><strong>Santiago:</strong> MCU code (I2S+DMA audio, SD Card/FatFs, SPI protocol, TFT display driver), FPGA logic (Hit capture, timestamp, FIFO)</li>
<li><strong>All Members:</strong> Debugging, documentation, and final presentation</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/abe-3\.github\.io\/E155-Microprocessors\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>