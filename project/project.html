<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Project Proposal – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../labs/labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#microcontroller-integration" id="toc-microcontroller-integration" class="nav-link" data-scroll-target="#microcontroller-integration">Microcontroller Integration</a></li>
  <li><a href="#fpga-integration" id="toc-fpga-integration" class="nav-link" data-scroll-target="#fpga-integration">FPGA Integration</a></li>
  <li><a href="#calculations" id="toc-calculations" class="nav-link" data-scroll-target="#calculations">Calculations</a></li>
  <li><a href="#bill-of-materials-budget" id="toc-bill-of-materials-budget" class="nav-link" data-scroll-target="#bill-of-materials-budget">Bill of Materials / Budget</a></li>
  <li><a href="#project-timeline-weeks-815" id="toc-project-timeline-weeks-815" class="nav-link" data-scroll-target="#project-timeline-weeks-815">Project Timeline — Weeks 8–15</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#action-items" id="toc-action-items" class="nav-link" data-scroll-target="#action-items">Action Items</a></li>
  <li><a href="#task-division" id="toc-task-division" class="nav-link" data-scroll-target="#task-division">Task Division</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project Proposal</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>DDRUM is a four-pad rhythm game in the spirit of DDR and Guitar Hero. Notes descend in four lanes on a display while a song plays. The player strikes one of four drum pads on the beat, and the system scores accuracy as Perfect, Good, or Miss with real-time visual feedback and a running score/combo.</p>
<p>The STM32L432 (Nucleo-L432KCU) acts as the timekeeper and system coordinator: it plays audio, timestamps pad hits, and streams visual data, and hit events to the iCE40UP5K (UPduino v3.1) FPGA over SPI. The FPGA renders the lanes and sprites at 640×480 @ 60 Hz and performs time-window scoring against the same timebase the MCU maintains. The result is a responsive, low-latency game that cleanly divides responsibilities: MCU for sensing, timing, and audio; FPGA for graphics and scoring logic. Success is defined as smooth 60 FPS visuals with four color lanes and readable targets consistent audio-visual synchronization across at least one complete charted song, consistent and accurate pad detection with low false triggers, and real-time judgments displayed without perceptible lag. The design uses both the MCU and FPGA in roles beyond prior labs and introduces non-trivial new hardware: a resistor-ladder VGA DAC, piezo sensor front-ends, and either a DFPlayer audio path or a PWM/DAC path.</p>
</section>
<section id="microcontroller-integration" class="level3">
<h3 class="anchored" data-anchor-id="microcontroller-integration">Microcontroller Integration</h3>
<p>The Nucleo-L432 provides a 1 kHz timer (or SysTick) to maintain song timing as the single time source for the entire system. It owns the visual data, schedules playback, and sends time stamp signals to the FPGA at video cadence so rendering stays phase-locked to audio. Four piezo disks mounted under pads feed simple analog front-ends. The MCU uses either the ADC analog watchdog or a comparator to raise an interrupt on being hit. We will then apply a short window of grace (about 20-30 ms) and a short signal hold to debounce a potentially buggy signal and get the fastest timestamp.</p>
<p>For audio there are two options. Option A (preferred) uses a DFPlayer Mini on UART 9600 to play MP3 from microSD; the MCU controls transport and maintains time from its own timer so that audio and visuals share the same master clock. Option B (fallback) generates PCM on the MCU with timer-DMA into a PWM or DAC output, lightly filtered and amplified to a small speaker. In either case the MCU also manages Start/Select/Pause buttons via EXTI GPIO and streams chart data to the FPGA prior to play. This combination of ADC watchdog/comparator interrupts, deterministic SPI scheduling tied to a master clock, and external audio control is beyond prior labs.</p>
</section>
<section id="fpga-integration" class="level3">
<h3 class="anchored" data-anchor-id="fpga-integration">FPGA Integration</h3>
<p>On the iCE40UP5K the video pipeline uses standard 640×480p60 timing derived from an internal PLL running a ~25.2 MHz pixel clock. Horizontal and vertical counters generate pixel coordinates during the active region. Rather than allocate a full framebuffer, the renderer is a streaming compositor: for each pixel it decides which lane it falls into and whether a note sprite should be shown at that (x, y) based on the song time. A small BRAM region holds compact note tuples (drum number, time of hit) that are preloaded from the MCU before play. A separate palette/glyph LUT stores 1-bit masks for note hit flashes, and simple HUD glyphs. The mapping from scheduled onset to screen position is y = y0 + v · (sont time − hit time), where the scroll rate v is set by the chart header. A dedicated scoring core in the FPGA receives hit events from the MCU (lane and timestamp) and compares them to the nearest scheduled onset using fixed thresholds (for example ±35 ms Perfect, ±75 ms Good, Miss beyond ±120 ms). It updates combo and score, which the renderer overlays as HUD elements. The SPI slave on the FPGA parses four message types from the MCU: an INIT_HDR that carries BPM/scroll and palette parameters; NOTE_CHUNK blocks that populate BRAM; a periodic TIME_BEACON (about every 16.7 ms) that sets the authoritative song_time_ms; and immediate HIT_EVENT packets as pad interrupts occur. Video drives a simple binary-weighted 4-bit R/G/B DAC per color plus HSYNC/VSYNC to a VGA connector. This combination of a streaming sprite/LUT compositor, protocol parsing, and VGA timing extends well beyond what was covered in labs.</p>
</section>
<section id="calculations" class="level3">
<h3 class="anchored" data-anchor-id="calculations">Calculations</h3>
<p>Video timing. 640×480 active pixels at <span class="math inline">\(\approx 60\)</span> Hz uses a <span class="math inline">\(\approx 25.2\)</span> MHz pixel clock. The streaming compositor removes the need for a full framebuffer; BRAM only stores glyphs and a compact note list. Scroll mapping. At 60 FPS each frame advances by 16.67 ms. If we want a note to travel 360 px in 2000 ms, the scroll rate is <span class="math inline">\(v = \frac{360}{2000} = \frac{0.18 px}{ms}\)</span>, so the per-frame step is <span class="math inline">\(\delta y \approx 3\)</span> px. SPI bandwidth. Preloading a chart of about 1200 notes with 5 bytes per tuple is ~6 KB, transmitted before the song. Runtime traffic is minimal: a TIME_BEACON every frame (~60 Hz) with a few bytes and HIT_EVENTs as the player strikes. An 8–12 MHz SPI clock provides wide margin. Latency budget. Pad analog to interrupt is typically under 100 µs; packaging and SPI transmission are about 50–150 µs; the FPGA overlays judgment on the next frame (<span class="math inline">\(\le\)</span> 16.7 ms). End-to-end feedback is therefore comfortably under 10 ms typical, leaving ample room for Perfect/Good windows at <span class="math inline">\(\pm 35/ \pm 75\)</span> ms. Power and levels. Logic runs at 3.3 V; audio/DFPlayer at 5 V with a common ground. Each VGA color channel is limited to ~0.7 Vpp into 75 <span class="math inline">\(\Omega\)</span> using a 4-bit resistor ladder with 1% tolerance and a 75 Ω series resistor per channel. No FFT processing is required in this design; key performance determinants are video timing, serial bandwidth, interrupt timing, and end-to-end latency.</p>
</section>
<section id="bill-of-materials-budget" class="level3">
<h3 class="anchored" data-anchor-id="bill-of-materials-budget">Bill of Materials / Budget</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th>Part / ID</th>
<th>Qty</th>
<th>Source</th>
<th>Est. Price</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>FPGA board</strong></td>
<td>UPduino v3.1 (iCE40UP5K)</td>
<td>1</td>
<td>Provided</td>
<td>$0.00</td>
<td></td>
</tr>
<tr class="even">
<td><strong>MCU board</strong></td>
<td>Nucleo-L432KCU (STM32L432KC)</td>
<td>1</td>
<td>Provided</td>
<td>$0.00</td>
<td></td>
</tr>
<tr class="odd">
<td>Piezo discs (27–35 mm)</td>
<td>e.g., ABT-402-RP or generic</td>
<td>4</td>
<td></td>
<td>$4.00</td>
<td>Drum sensors ($1.00 each)</td>
</tr>
<tr class="even">
<td>Schottky diodes</td>
<td>BAT54 or similar</td>
<td>4</td>
<td></td>
<td>$7.00</td>
<td>Clamp to rails</td>
</tr>
<tr class="odd">
<td>AFE passives</td>
<td>10k/100k resistors, 100 nF caps (1%)</td>
<td>set</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Divider / RC</td>
</tr>
<tr class="even">
<td>Momentary buttons</td>
<td>12 mm tactiles</td>
<td>3</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Start / Select / Pause</td>
</tr>
<tr class="odd">
<td>DFPlayer Mini</td>
<td>YX5200-24SS module</td>
<td>1</td>
<td></td>
<td>$6.00</td>
<td>Audio output</td>
</tr>
<tr class="even">
<td>microSD card</td>
<td>≥1 GB</td>
<td>1</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>For DFPlayer</td>
</tr>
<tr class="odd">
<td>Audio amplifier</td>
<td>PAM8403 module</td>
<td>1</td>
<td></td>
<td>$2.00</td>
<td>3 W class-D</td>
</tr>
<tr class="even">
<td>Speaker</td>
<td>8 Ω 0.5–3 W</td>
<td>1</td>
<td></td>
<td>$2.00</td>
<td>Audio output</td>
</tr>
<tr class="odd">
<td>VGA DAC resistors</td>
<td>1 % sets: 1k, 2k, 4k, 8k + 75 Ω series</td>
<td>12</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>4-bit per color</td>
</tr>
<tr class="even">
<td>Perfboard / wiring</td>
<td>—</td>
<td>—</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Interconnects, DAC</td>
</tr>
<tr class="odd">
<td>Enclosure materials</td>
<td>—</td>
<td>—</td>
<td>Makerspace</td>
<td>$0.00</td>
<td>Plywood + 3D printer filament</td>
</tr>
</tbody>
</table>
<p><strong>Subtotal (purchased items): $21.00</strong></p>
<section id="display-output-options-choose-one" class="level4">
<h4 class="anchored" data-anchor-id="display-output-options-choose-one"><strong>Display / Output Options (choose one)</strong></h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Part / ID</th>
<th>Qty</th>
<th>Source</th>
<th>Est. Price</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VGA monitor + cable</td>
<td>—</td>
<td>1</td>
<td>Stockroom</td>
<td>$0.00</td>
<td>Any VGA display</td>
</tr>
<tr class="even">
<td><a href="https://www.adafruit.com/product/607">LED Matrix</a></td>
<td>0607</td>
<td>1</td>
<td>Adafruit</td>
<td>$30.00</td>
<td></td>
</tr>
<tr class="odd">
<td><a href="https://www.digikey.com/en/products/detail/adafruit-industries-llc/1680/10670023">LCD Screen</a></td>
<td>1680</td>
<td>1</td>
<td>Digikey</td>
<td>$27.50</td>
<td></td>
</tr>
<tr class="even">
<td>Fan Display: Motor + <a href="https://www.adafruit.com/product/2328">LED strip</a></td>
<td>2328</td>
<td>1</td>
<td>Adafruit</td>
<td>$25.00</td>
<td>Motor from stockroom</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="project-timeline-weeks-815" class="level3">
<h3 class="anchored" data-anchor-id="project-timeline-weeks-815">Project Timeline — Weeks 8–15</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Week</th>
<th>Date</th>
<th>Scheduled Topics</th>
<th>Deliverables</th>
<th>Project Milestone</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>8</strong></td>
<td>Oct 13</td>
<td><strong>Fall Break — No Class</strong>; Proposal Debriefs</td>
<td><a href="https://hmc-e155.github.io/project/">Project Proposal</a></td>
<td>—</td>
</tr>
<tr class="even">
<td><strong>9</strong></td>
<td>Oct 20</td>
<td>AES Lecture &amp; FPGA Workshop</td>
<td><a href="https://hmc-e155.github.io/lab/lab6/">Lab 6</a></td>
<td>3D Model the Drums and embed sensors</td>
</tr>
<tr class="odd">
<td><strong>10</strong></td>
<td>Oct 27</td>
<td>Graphics, Displays, Motors &amp; Speakers</td>
<td><a href="https://hmc-e155.github.io/lab/lab7/">Lab 7</a></td>
<td>Get Display Working and syncronize with music playing</td>
</tr>
<tr class="even">
<td><strong>11</strong></td>
<td>Nov 3</td>
<td>Design Review Presentations (T/Th)</td>
<td>Design Review Presentation &amp; Memo</td>
<td>Have working prototype model, have some pre-edited music samples</td>
</tr>
<tr class="odd">
<td><strong>12</strong></td>
<td>Nov 10</td>
<td>Intro to RTOS; Direct Memory Access</td>
<td>—</td>
<td>3D Model some housing for entire design</td>
</tr>
<tr class="even">
<td><strong>13</strong></td>
<td>Nov 17</td>
<td>Project Status Report &amp; Demo; Connectors</td>
<td>Project Status Reports &amp; Demo</td>
<td>Demo working project to Prof.&nbsp;Spencer</td>
</tr>
<tr class="odd">
<td><strong>14</strong></td>
<td>Nov 24</td>
<td>FFT Lecture; <strong>Thanksgiving — No Class (Th)</strong></td>
<td>—</td>
<td>Fix what’s broken, debugging</td>
</tr>
<tr class="even">
<td><strong>15</strong></td>
<td>Dec 4</td>
<td>Digital Signal Processing; Special Topics / Guest Lecture</td>
<td>Project Checkoffs, Report, Demo Day</td>
<td><strong>Win or Die</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<figure style="flex:1 1 30%; text-align:center;" class="figure">
<img src="images/blockdiagram.png" alt="Block Diagram" style="width:100%; border-radius:8px;" class="figure-img">
<figcaption>
Block Diagram
</figcaption>
</figure>
</section>
<section id="action-items" class="level3">
<h3 class="anchored" data-anchor-id="action-items">Action Items</h3>
<ul class="task-list">
<li><label><input type="checkbox"><strong>Finalize Audio Path (MCU side)</strong> – Implement DFPlayer UART control and verify synchronization with system timer.<br>
</label></li>
<li><label><input type="checkbox"><strong>Develop Pad Detection Circuit</strong> – Build and test piezo AFE and comparator/ADC interrupt response.<br>
</label></li>
<li><label><input type="checkbox"><strong>SPI Communication Protocol</strong> – Define and implement INIT, NOTE_CHUNK, TIME_BEACON, and HIT_EVENT messages between MCU and FPGA.<br>
</label></li>
<li><label><input type="checkbox"><strong>FPGA Video Pipeline</strong> – Implement 640×480 VGA timing, streaming compositor, and BRAM note storage.<br>
</label></li>
<li><label><input type="checkbox"><strong>Scoring Logic</strong> – Design and verify time-window scoring (Perfect/Good/Miss) on FPGA.<br>
</label></li>
<li><label><input type="checkbox"><strong>HUD &amp; Sprite Rendering</strong> – Create lane graphics, combo counter, and hit flash overlays.<br>
</label></li>
<li><label><input type="checkbox"><strong>Mechanical Integration</strong> – Assemble four-pad drum enclosure with sensor mounts and wiring.<br>
</label></li>
<li><label><input type="checkbox"><strong>System Integration Test</strong> – Synchronize audio, visuals, and pad timing; validate latency budget.<br>
</label></li>
<li><label><input type="checkbox"><strong>Final Debug and Polish</strong> – Tune thresholds, test multiple charts, and prepare final demo.</label></li>
</ul>
</section>
<section id="task-division" class="level3">
<h3 class="anchored" data-anchor-id="task-division">Task Division</h3>
<ul>
<li><strong>Abe:</strong> MCU code (drum sensing, audio integration), Scoring logic, Mechanical design (drum pad housing, sensor mounting)</li>
<li><strong>Santiago:</strong> MCU code (timing, SPI protocol), FPGA graphics pipeline, VGA output,</li>
<li><strong>All Members:</strong> Debugging, documentation, and final presentation</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/abe-3\.github\.io\/E155-Microprocessors\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>